#+TITLE: Configuración de GNU Emacs
#+AUTHOR: Jorge Javier Araya Navarro (Shackra Sislock)
#+EMAIL: jorge@esavara.cr
#+OPTIONS: toc:5 num:nil ^:nil
#+STARTUP: overview

#+begin_example
                                                 🕇
                              Actiones nostras tibi comítimus, Dómine,
                               ut ad maiorem gloriam tuam repleamur.
                                               🕇   🕇
#+end_example

* Configuración de GNU Emacs en un archivo de org-mode
He decidido mover mi configuración a un sólo archivo. Anteriormente mi configuración estaba dividida en varios archivos =.el=, esto no era malo, sin embargo debo estar visitando diferentes archivos si deseo realizar varios cambios en mi configuración creándome una plétora de buffers en Emacs. Además, con =org-mode= me es posible documentar varios aspectos de mi configuración. Sí, sí... ya sé que esto se puede hacer con comentarios en el código. Otro beneficio de usar =org-mode= y =babel= es la capacidad de contraer o expandir varias secciones de la configuración, o navegar rápidamente entre secciones (cosa que aun no sé hacer), además, con Babel no me veo restringido a ejecutar solamente código elisp ¡también puedo correr código Python!.

#+BEGIN_SRC emacs-lisp
  ;; sombrero de aluminio, le bajamos una rayita
  (setq network-security-level 'high)

  (defun shackra/update-one-package (package)
    "Actualiza un paquete PACKAGE"
    (when (package-installed-p package)
      (let* ((newest-pkg (car-safe (cdr (assq package package-archive-contents))))
             (new-ver (and newest-pkg (package-desc-version newest-pkg)))
             (builtin-pkg (cdr (assq package package--builtins)))
             (installed-pkg (car-safe (cdr (assq package package-alist))))
             (old-dir (and installed-pkg (package-desc-dir installed-pkg)))
             (old-ver (or (and installed-pkg (package-desc-version installed-pkg))
                         (and builtin-pkg (package--bi-desc-version builtin-pkg)))))
        (when (and new-ver (version-list-< old-ver new-ver))
          ;; Instalamos la nueva versión de org-mode
          (condition-case nil
              ;; en caso de algún error tratando de bajar algún paquete, captura
              ;; el error para que no interfiera con la inicialización de Emacs
              (progn (package-install newest-pkg)
                     (message (format "Paquete «%s» actualizado de la versión %s a la versión %s"
                                      (package-desc-name newest-pkg) old-ver new-ver))))
          (when old-dir
            (delete-directory old-dir t))))))

  (unless package-archive-contents
    (package-refresh-contents))

  ;; Instala use-package si no esta disponible
  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))

  (if (not (package-installed-p 'org))
      (package-install 'org)
    ;; El paquete esta instalado. Actualiza el paquete org-mode.
    (shackra/update-one-package 'org))

  (when (not (package-installed-p 'diminish))
      (package-install 'diminish))

  (when (not (package-installed-p 'bind-key))
      (package-install 'bind-key))

  (when (not (package-installed-p 'f))
      (package-install 'f))

  ;; Arreglo para LaTeX con Emacs en MacOS "El Capitan"
  (when (eq system-type 'darwin)
    (setf exec-path (append exec-path '("/Library/TeX/texbin"))))

  ;; En caso de que /usr/local/bin no este agregado
  (when (and (not (member "/usr/local/bin" exec-path)) (or (not (eq system-type 'windows-nt))
                                                      (not (eq system-type 'cygwin))
                                                      (not (eq system-type 'ms-dos))))
    (setf exec-path (append exec-path '("/usr/local/bin")))
    (setenv "PATH" "/usr/local/bin:/Library/TeX/texbin/:$PATH" t))

  (eval-when-compile
    (require 'use-package))
  (require 'diminish)
  (require 'bind-key)

  (setf use-package-always-ensure t)

  (defun shackra/org-confirm-babel-evaluate (lang body)
    (not (or (string= lang "emacs-lisp"))))
  (setf org-confirm-babel-evaluate #'shackra/org-confirm-babel-evaluate)

  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
#+END_SRC
* Información personal
La ubicación geográfica usada es la de San José, Costa Rica siendo tan pequeño hace innecesario especificar nuestra ubicación geográfica exacta.
#+BEGIN_SRC emacs-lisp
  (setf user-full-name "Jorge Javier Araya Navarro"
        user-mail-address "jorge@esavara.cr"
        calendar-location-name "Heredia, CR"
        calendar-latitude 9.935607
        calendar-longitude -84.1833856)
#+END_SRC
* Repositorio de paquetes
Desde la versión 24 Emacs permite la instalación de paquetes de la misma manera como se realiza en distribuciones de GNU/Linux.

El sistema de paquetes de Emacs no es perfecto, para que algunos paquetes funcionen como deben aun debes poner algunas cosas en tu configuración de Emacs y tal. Revisa la descripción de cualquier paquetes que vayas a instalar para tener más información. Para ver qué paquetes hay disponibles, y cuales desea instalar, puede hacer uso del comando =M-x package-list-packages=
* Códigos Elisp
funciones de Emacs lisp escritas por mi u otras personas (y que yo he recolectado para mi uso personal)
** Inspector de entradas org-mode
Convierte un elemento org-mode bajo el puntero en su equivalente elisp para inspección
#+BEGIN_SRC emacs-lisp
  (defun org-inspect-element-at-point ()
    "Inspecciona el elemento org-mode en su forma elisp"
    (interactive)
    (let ((body (org-element-context)))
      (switch-to-buffer (get-buffer-create "*org-inspect-element-at-point*"))
      (erase-buffer)
      (insert (format "'%s" body))
      (pp-buffer)))

  (defun org-inspect-element-buffer ()
    "Inspecciona todo el documento org-mode en su forma elisp"
    (interactive)
    (let ((body (org-element-parse-buffer)))
      (switch-to-buffer (get-buffer-create "*org-inspect-element-buffer*"))
      (erase-buffer)
      (insert (format "'%s" body))
      (pp-buffer)))

  (defun org-inspect-buffer-clocktable ()
    "Inspecciona el documento org-mode en su forma elisp como una tabla org-clock"
    (interactive)
    (let ((body (org-clock-get-table-data (buffer-name) nil)))
      (switch-to-buffer (get-buffer-create "*org-inspect-buffer-clocktable*"))
      (erase-buffer)
      (insert (format "'%s" body))
      (pp-buffer)))
#+END_SRC
** función para insertar etiquetas <kbd>
Gracias a Malabarba en su [[http://emacs.stackexchange.com/a/2208/690][respuesta desde Emacs.stackexchange]].
#+BEGIN_SRC emacs-lisp
  (defun endless/insert-key (key)
    "Ask for a key then insert its description.
  Will work on both org-mode and any mode that accepts plain html."
    (interactive "kType key sequence: ")
    (let* ((is-org-mode (derived-mode-p 'org-mode))
           (tag (if is-org-mode
                    "@@html:<kbd>%s</kbd>@@"
                  "<kbd>%s</kbd>")))
      (if (null (equal key "\r"))
          (insert
           (format tag (help-key-description key nil)))
        (insert (format tag ""))
        (forward-char (if is-org-mode -8 -6)))))
#+END_SRC
** funciones con expresiones regulares que uso a menudo en edición de texto
estas son funciones que uso muy a menudo durante la edición de texto, tenerlos como comandos interactivos me ahorra tiempo escribiendo las expresiones regulares una y otra vez.

#+BEGIN_SRC emacs-lisp
  (defun shackra/no-saltos-linea (start end)
    "Elimina todos los saltos de linea en la selección"
    (interactive "r")
    (vr/replace "\n+" " " start end))

  (defun shackra/no-multiple-espacios (start end)
    "Elimina todos los espacios en blanco seguidos en la selección"
    (interactive "r")
    (vr/replace " +" " " start end))
#+END_SRC
** =find-file= y =switch-buffer= personalizados
Problema: Cuando estoy dentro de un proyecto con Projectile-mode, me gusta visitar archivos y buffers relacionados con el proyecto en el cual estoy trabajando.

Solución: Crear mis funciones personalizadas para =find-file= y =switch-buffer=.

Teclas
- @@html:<kbd>C-x C-f</kbd>@@ :: Visitar archivo. *Dentro de un proyecto*: Visita archivo de proyecto, prefijo @@html:<kbd>C-u</kbd>@@ Visitar archivo, prefijo @@html:<kbd>C-u</kbd>@@ @@html:<kbd>C-u</kbd>@@ =ag= para buscar una cadena de texto entre miles de archivos.
- @@html:<kbd>C-x b</kbd>@@ :: Cambiar buffer. *Dentro de un proyecto*: Cambiar buffer de archivo relacionado a proyecto, prefijo @@html:<kbd>C-u</kbd>@@ Cambiar buffer, prefijo @@html:<kbd>C-u</kbd>@@ @@html:<kbd>C-u</kbd>@@ Inicia menú Hydra para Windmove.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "ivy"
    (with-eval-after-load "projectile"
      (with-eval-after-load "counsel"
        (defun mi/find-file (arg)
          (interactive "p")
          (cond
           ((eq arg 4) (counsel-find-file))
           ((eq arg 16) (counsel-ag))
           ((eq arg 1) (if (projectile-project-p) (projectile-find-file-dwim) (counsel-find-file)))))

        (defun mi/switch-buffer (arg)
          (interactive "p")
          (cond
           ((eq arg 4) (ivy-switch-buffer))
           ((eq arg 16) (hydra-win/body))
           ((eq arg 1) (if (projectile-project-p) (projectile-switch-to-buffer) (ivy-switch-buffer)))))
        ;; Remapea los atajos con mis propios comandos
        (global-set-key [remap find-file] #'mi/find-file)
        (global-set-key [remap switch-to-buffer] #'mi/switch-buffer))))
#+END_SRC
** función para =delete-frame-functions=
#+BEGIN_SRC emacs-lisp
  (defun shackra/run-delete-frame-hooks (frame)
    "Esta función corre algunas funciones que no son llamadas cuando Emacs
  corre como proceso de segundo plano"
    (when (server-running-p)
      (savehist-save)
      (recentf-save-list)))

  (add-hook 'delete-frame-functions 'shackra/run-delete-frame-hooks)
#+END_SRC
** salva algunos buffers al perder Emacs el foco
Sacado de [[http://timothypratley.blogspot.nl/2015/07/seven-specialty-emacs-settings-with-big.html][Programming: Seven specialty Emacs settings with big payoffs]]

#+BEGIN_SRC emacs-lisp
  (defun guardar-todo ()
    (interactive)
    (save-some-buffers t))

  ;; uso:
  ;; (add-hook 'focus-out-hook #'guardar-todo)
#+END_SRC
** No molestes, Shia LaBeouf!
#+BEGIN_SRC emacs-lisp
  (defun shackra/org-reschedule-tomorrow ()
    "Re-Programa para mañana una tarea que pude hacer hoy"
    (interactive)
    (org-schedule :time (format-time-string "%Y-%m-%d" (time-add (current-time) (seconds-to-time 86400)))))
#+END_SRC
** Modificación de los caracteres en el mode-line
Los caracteres en el mode-line de Emacs pueden ser modificados ¿No es genial? (según [[http://tromey.com/blog/?p%3D831][The Cliffs of Inanity]], también [[http://www.lunaryorn.com/2014/07/26/make-your-emacs-mode-line-more-useful.html][lunarsite]]. referencias sobre =mode-line-format= en la [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Format.html][referencia de Elisp]])

#+BEGIN_SRC emacs-lisp
  (defvar shackra/vc-mode nil)
  (make-variable-buffer-local 'shackra/vc-mode)

  (require 'vc)
  (defun shackra/vc-command-hook (&rest args)
    (let ((file-name (buffer-file-name)))
      (setq shackra/vc-mode (and file-name
                                 (not (vc-registered file-name))
                                 (ignore-errors
                                   (vc-responsible-backend file-name))))))

  (add-hook 'vc-post-command-functions #'shackra/vc-command-hook)
  (add-hook 'find-file-hook #'shackra/vc-command-hook)

  (defun shackra/vc-info ()
    (if shackra/vc-mode
        (propertize "±" 'face 'error)
      " "))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; Si usas `powerline', editar la variable mode-line-format es algo complicado,
  ;; pero no imposible
  (setq-default mode-line-format
                '("%e"
                  (:eval (if (buffer-modified-p)
                             (propertize " ↓ " 'face 'error)
                           "  "))
                  (:eval (shackra/vc-info))
                  " " mode-line-buffer-identification
                  " " mode-line-position
                  " " mode-line-modes
                  mode-line-misc-info))
#+END_SRC
** =defadvice= temporal
#+BEGIN_SRC emacs-lisp
  (defmacro my/with-advice (adlist &rest body)
    "Execute BODY with temporary advice in ADLIST.

  Each element of ADLIST should be a list of the form
    (SYMBOL WHERE FUNCTION [PROPS])
  suitable for passing to `advice-add'.  The BODY is wrapped in an
  `unwind-protect' form, so the advice will be removed even in the
  event of an error or nonlocal exit."
    (declare (debug ((&rest (&rest form)) body))
             (indent 1))
    `(progn
       ,@(mapcar (lambda (adform)
                   (cons 'advice-add adform))
                 adlist)
       (unwind-protect (progn ,@body)
         ,@(mapcar (lambda (adform)
                     `(advice-remove ,(car adform) ,(nth 2 adform)))
                   adlist))))
#+END_SRC
** Omitir confirmación para =y-or-n-p=
#+BEGIN_SRC emacs-lisp
  (defun my/bypass-confirmation (function &rest args)
    "Call FUNCTION with ARGS, bypassing all `y-or-n-p' prompts."
    (my/with-advice
     ((#'y-or-n-p :override (lambda (prompt) t)))
     (apply function args)))

  (defun my/bypass-confirmation-all (function &rest args)
    "Call FUNCTION with ARGS, bypassing all prompts.
  This includes both `y-or-n-p' and `yes-or-no-p'."
    (my/with-advice
     ((#'y-or-n-p    :override (lambda (prompt) t))
      (#'yes-or-no-p :override (lambda (prompt) t)))
     (apply function args)))
#+END_SRC
** usar Emacsclient como git mergetool
#+BEGIN_SRC emacs-lisp
  (defun shackra/emerge (local remote base output)
    "difftool que se abre en emacsclient"
    (emerge-files-with-ancestor nil local remote base output nil 'shackra/emerge--close-current-frame))

  (defun shackra/emerge--close-current-frame ()
    "Cierra el frame actual"
    (delete-frame (selected-frame)))
#+END_SRC
Para hacer que Git use emacsclient como /mergetool/ hay que modificar la configuración de Git
#+BEGIN_EXAMPLE
  [merge]
          tool = emacsclient
  [mergetool "emacsclient"]
          cmd = emacsclient -c -a \"\" --eval \"(shackra/emerge \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" \\\"$OUTPUT\\\")\"
          trustExitCode = true
#+END_EXAMPLE
** Generar enlaces de descargas para descargas directas y BitTorrent
#+BEGIN_SRC emacs-lisp
  (defun shackra/owp-descargas (title hashalist)
    "Enlaces Magnet a HTML."
    (let* ((nuevalista '())
           (nuevoelement (ht-create))
           (uri "")
           (nombre "")
           (tipo "")
           (!torrent)
           (mustache-partial-paths (list (expand-file-name "" user-emacs-directory))))
      ;; recreamos la lista en `hashalist' como una lista ht
      (dolist (e hashalist)
        (setf nombre (car e))
        (setf !torrent (car (cddr e)))
        (if !torrent
            (progn
              (setf uri (car (cdr e)))
              (setf tipo "directa"))
          (progn
            (setf tipo "con BitTorrent")
            (setf uri (format "magnet:?xt=urn:btih:%s&dn=%s&tr=%s"
                              (car (cdr e))
                              (url-hexify-string (car e))
                              (url-hexify-string (concat "udp://tracker.openbittorrent.com:80"
                                                         "&tr=udp://opentor.org:2710"
                                                         "&tr=udp://tracker.ccc.de:80"
                                                         "&tr=udp://tracker.blackunicorn.xyz:6969"
                                                         "&tr=udp://tracker.coppersurfer.tk:6969"
                                                         "&tr=udp://tracker.leechers-paradise.org:6969"))))))
        (ht-set! nuevoelement "nombre" nombre)
        (ht-set! nuevoelement "uri" uri)
        (ht-set! nuevoelement "es-torrent" (not !torrent))
        (ht-set! nuevoelement "tipo" tipo)
        (add-to-list 'nuevalista (ht-copy nuevoelement)))
      (mustache-render "{{> descargas}}" (ht ("hash-alist" nuevalista) ("titulo" title)))))
#+END_SRC
** Probar si un puerto esta abierto
#+BEGIN_SRC emacs-lisp
  (defun shackra/port-open-p (server port)
    (let* ((conn nil))
      (condition-case err
          (progn
            (setf conn (open-network-stream "test-port-open" nil server port))
            (stop-process conn)
            t)
        (file-error nil))))
#+END_SRC
** Comprobar si un modulo Python existe
#+BEGIN_SRC emacs-lisp
  (defun shackra/python-module-exist-p (module)
    "Retorna `t' si el modulo `MODULE' existe"
    (let ((exists (string-trim (shell-command-to-string (format "python -c 'import pkgutil; print(0 if pkgutil.find_loader(\"%s\") else 1)'" module)))))
      (when (string= exists "0")
        t)))
#+END_SRC
** Convertir =hh:mm= a formato de punto flotante
#+BEGIN_SRC emacs-lisp
  (defun shackra/time--to-seconds (timestr)
    "Convierte la notacion HH:MM a segundos"
    (let* ((matchindex (string-match "\\([0-9]+\\):\\([0-9]+\\)" timestr))
           (hours (string-to-number (match-string 1 timestr)))
           (minutes (string-to-number (match-string 2 timestr))))
      (+ (* 60 (* hours 60)) (* minutes 60))))

  (defun shackra/time-to-hours (timestr)
    "Expresa el tiempo en notacion de punto decimal"
    (format "%.3f" (/ (shackra/time--to-seconds timestr) 3600.0)))
#+END_SRC
** Apaga el auto sangrado
#+BEGIN_SRC emacs-lisp
  (defun shackra/electric-indent-mode-off ()
    (electric-indent-local-mode -1)
    ;; Desactiva aggresive-indent si esta instalado y activo
    (when (fboundp 'aggressive-indent-mode)
      (aggressive-indent-mode -1)))
#+END_SRC
* Macros
#+BEGIN_SRC emacs-lisp
  (fset 'untangle-use-packages
        [?\C-s ?\( delete ?u ?s ?e ?- ?p ?a ?c ?k ?a ?g ?e prior return ?\C-\M-b ?\C-  ?\C-\M-f ?\C-\M-f ?\M-x ?c ?o ?p ?y ?  ?t ?o return ?p ?\C-s ?\( delete ?u ?s ?e ?- ?p ?a ?c ?k ?a ?g ?e next up return ?\C-f ?\C-  ?\C-\M-f ?\M-x ?c ?o ?p ?y ?  return ?n ?\C-s ?\( delete ?u ?s ?e ?- ?p ?a ?c ?k ?a ?g ?e next return ?\C-\M-b ?\C-b ?\C-c ?0 ?\C-w ?\M-x ?b ?e ?g down down down down return return ?\M-x ?b ?e down down down down return ?\C-y ?\C-s ?\( delete ?u ?s ?e ?- ?p ?a ?c ?k ?a ?g ?e prior return ?\C-\M-f return ?: ?a ?f ?t ?e ?r ?  ?\( ?\M-x ?i ?n ?s ?e ?r ?t down down down return ?n ?\C-s ?\M-x ?i ?n ?s ?e ?r ?t ?  ?r ?e ?g return ?p return])
#+END_SRC
* Custom.el
 El archivo customize sera éste. Cualquier modificación de Emacs que se haga a través de =customize= ira al archivo especificado.

#+BEGIN_SRC emacs-lisp
  (setf custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC
* Division de ventanas y movimiento inmediato del cursor a la nueva ventana
Combinaciones de teclas que no pertenecen a ningún paquete en particular.
#+BEGIN_SRC emacs-lisp
  (defun shackra/split-window-vertically ()
    "Divide la ventana por la mitad verticalmente y mueve el cursor a la ventana nueva"
    (interactive)
    (split-window-vertically)
    (other-window 1))

  (defun shackra/split-window-horizontally ()
    "Divide la ventana por la mitad horizontalmente y mueve el cursor a la ventana nueva"
    (interactive)
    (split-window-horizontally)
    (other-window 1))

  (global-set-key [remap split-window-below] #'shackra/split-window-vertically)
  (global-set-key [remap split-window-right] #'shackra/split-window-horizontally)
#+END_SRC
* Aliases
Nombres más cortos para comandos usados frecuentemente
#+BEGIN_SRC emacs-lisp
  (defalias 'eb 'eval-buffer)
  (defalias 'er 'eval-region)
  (defalias 'ed 'eval-defun)
#+END_SRC
* Paquetes de extensiones
** Utilidades
*** =better-defaults=
configuración sana de ciertas opciones en Emacs
#+BEGIN_SRC emacs-lisp
  (use-package better-defaults
    :config
    ;; Se cargan otras modificaciones para mejorar el comportamiento de Emacs
    (load-file (expand-file-name "sane.el" user-emacs-directory))
    (ido-mode nil))
#+END_SRC
**** Tipografía
Función que comprueba disponibilidad de tipografías en el sistema, además de establecer la tipografía.
#+BEGIN_SRC emacs-lisp
  (defun font-exists-p (font)
    "Comprueba si una tipografía existe. Sacado de https://redd.it/1xe7vr"
    (if (not (find-font (font-spec :name font)))
        nil
      t))

  (defun shackra/arregla-emojis (&optional frame)
    "Arregla la visualizacion de los emojis"
    ;; Para NS/Cocoa
    (when (eq system-type 'darwin)
      (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend))
    ;; Para todos los demas sistemas operativos
    (when (and (font-exists-p "Symbola") (not (eq system-type 'darwin)))
      (set-fontset-font t 'symbol (font-spec :size 20 :name "Symbola") frame 'prepend)))

  (defun shackra/font-set (&optional frame)
    "Establece una tipografia para el nuevo marco creado"
    (when (framep frame)
      (select-frame frame))
    (cond
     ((font-exists-p "Fira Code") (set-frame-font "Fira Code 10") (add-to-list 'default-frame-alist '(font . "Fira Code-10")))
     ((font-exists-p "Monoisome") (set-frame-font "Monoisome 9") (add-to-list 'default-frame-alist '(font . "Monoisome-9")))
     ((font-exists-p "Monoid") (set-frame-font "Monoid 9") (add-to-list 'default-frame-alist '(font . "Monoid-9")))
     ((font-exists-p "Source Code Pro") (set-frame-font "Source Code Pro 10") (add-to-list 'default-frame-alist '(font . "Source Code Pro-10")))))

  (add-hook 'after-make-frame-functions #'shackra/arregla-emojis)
  (add-hook 'after-make-frame-functions #'shackra/font-set)

  (unless (daemonp)
    (shackra/arregla-emojis)
    (shackra/font-set))
#+END_SRC
*** secreto
Saca cualquier rastro de tus archivos y datos privados de tu configuración de Emacs
#+BEGIN_SRC emacs-lisp
  (use-package secreto
    :ensure nil
    :load-path "site-packages/secreto.el/"
    :config
    (load-secretos))
#+END_SRC
*** secretaria
Mi intento de hacer algo mejor que [[*=appt=][=appt-mode=]].
#+BEGIN_SRC emacs-lisp
  (use-package secretaria
    :after (f alert)
    :load-path "site-packages/secretaria/"
    :ensure nil
    :init
    (setf secretaria-clocked-task-save-file "~/.secretaria-tarea")
    :config
    (secretaria-today-unknown-time-appt-always-remind-me))
#+END_SRC
*** =font-man=
Escala la altura de la tipografía en todos los buffers de manera temporal
#+BEGIN_SRC emacs-lisp
  (use-package switch-buffer-functions
    :commands (switch-buffer-functions-run))
  (use-package font-man
    :commands (font-man-mode)
    :after (switch-buffer-functions)
    :ensure nil
    :load-path "site-packages/font-man")
#+END_SRC
*** =swiper= & =ivy=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:46]
:END:
Reemplazo para =I-search=, Swiper es el nombre en inglés de Zorro, un personaje de la serie /Dora la exploradora/.

Teclas
- @@html:<kbd>C-s</kbd>@@  :: Buscar en buffer, reemplazando a =isearch-forward=
- @@html:<kbd>C-r</kbd>@@ :: Buscar en buffer, reemplazando a =isearch-backward=
- @@html:<kbd>C-c C-r</kbd>@@ :: Continua la ultima sesión de completado
- @@html:<kbd>M-x</kbd>@@ :: Fragmentos de texto /matados/ para pegar
- @@html:<kbd>C-h f</kbd>@@ :: Describe funciones
- @@html:<kbd>C-h v</kbd>@@ :: Describe variables
- @@html:<kbd>C-h b</kbd>@@ :: Describe atajos de teclado disponibles
- @@html:<kbd>C-x 8 RET</kbd>@@ :: Lista e inserta caracteres Unicode
- @@html:<kbd>C-x f</kbd>@@ :: Lista archivos visitados recientemente
- @@html:<kbd>C-x C-f</kbd>@@ :: Visita un archivo
- @@html:<kbd>C-x b</kbd>@@ :: Cambia de buffer
#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :commands (counsel-projectile counsel-projectile-switch-project counsel-projectile-switch-to-buffer)
    :after (counsel))
  (use-package counsel
    :after (ivy)
    :commands (counsel-org-tag)
    :bind (:map global-map
                ("M-x" . counsel-M-x)
                ("M-y" . counsel-yank-pop)
                :map help-map
                ("f" . counsel-describe-function)
                ("v" . counsel-describe-variable)
                ("b" . counsel-descbinds)
                :map ctl-x-map
                ("8 RET" . counsel-unicode-char)
                ("l" . counsel-locate)
                ("f" . counsel-recentf))
    :init
    (setf ivy-use-virtual-buffers nil)
    :config
    (with-eval-after-load 'org
      (global-set-key [remap org-set-tags-command] #'counsel-org-tag)))

  (use-package ivy-hydra
    :after (counsel-projectile))

  (use-package ivy
    :bind (:map global-map
                ("C-c C-r" . ivy-resume))
    :init
    (setf ivy-count-format "(%d/%d) ")
    (setf ivy-height 15)
    :config
    (add-to-list 'ivy-ignore-buffers "\\*weechat-relay")
    (add-to-list 'ivy-ignore-buffers "\\*Messages\\*")
    (add-to-list 'ivy-ignore-buffers "\\*elfeed-log\\*")
    (add-to-list 'ivy-ignore-buffers "\\*Help\\*")
    (add-to-list 'ivy-ignore-buffers "\\*Compile-Log\\*")
    (add-to-list 'ivy-ignore-buffers "\\*anaconda-mode\\*")
    (add-to-list 'ivy-ignore-buffers "\\*prodigy-.*")
    (add-to-list 'ivy-ignore-buffers "\\*godoc .*")
    (add-to-list 'ivy-ignore-buffers "\\*magit-.*")
    (add-to-list 'ivy-ignore-buffers "\\*Slack Log")
    (ivy-mode 1))

  (use-package swiper
    :commands (ivy-mode)
    :bind (:map global-map
                ("C-s" . swiper)
                ("C-r" . swiper)))
#+END_SRC
*** =hydra=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:45]
:END:
"/Cut off one head, Two more shall take its place. Hail HYDRA!/" [[http://marvel-movies.wikia.com/wiki/HYDRA][―miembro HYDRA]].

Permite tratar combinaciones de teclas como grupos... es algo difícil de explicar, puede ver este vídeo [[https://www.youtube.com/watch?v=_qZliI1BKzI][Switching Emacs windows with hydra and ace-window - YouTube]] para entender de qué trata este paquete.
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("M-o" . shackra/other-window)
    :init
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 3.0)))))
    (defun --count-frames ()
      "Retorna el numero de frames visibles"
      (let* ((frames (if (daemonp) (butlast (visible-frame-list) 1) (visible-frame-list))))
        (length frames)))
    (defun shackra/other-window ()
      "cambia la ventana en que el cursor esta"
      (interactive)
      (ace-window 0)
      (when (fboundp 'golden-ratio-mode)
        (golden-ratio)))
    :config
    (setf aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
  (use-package windmove
    :ensure nil)
  (use-package winner
    :ensure nil
    :config
    (winner-mode 1))
  (use-package windresize)
  (use-package hydra
    :after (windmove winner windresize ace-window)
    :preface
    (require 'hydra-examples)
    :init
    (defun shackra/python-indent-inclusive ()
      "Mueve el inicio de la región una linea por encima de `region-beginning'

  Actualmente esta función no funciona como se espera"
      (interactive)
      (save-excursion
        (let ((begin (region-beginning))
              (end (region-end)))
          (when (use-region-p)
            (goto-char begin)
            (forward-line -1)
            (push-mark end)
            (setq mark-active t)))))
    :config
    (defhydra hydra-py (:color red :pre (flycheck-mode -1) :post (progn (deactivate-mark) (flycheck-mode 1)))
      "Sangrado de bloques"
      ("," python-indent-shift-left "← Disminuir")
      ("." python-indent-shift-right "→ Aumentar"))
    (defhydra hydra-zoom (global-map "<f2>")
      "Acercamiento"
      ("f" text-scale-increase "in")
      ("j" text-scale-decrease "out"))
    (defhydra hydra-avy (:color blue :columns 2)
      "avy jump"
      ("z" avy-goto-line "Ir a la linea...")
      ("x" avy-goto-word-1 "Ir a la palabra...")
      ("c" avy-goto-char-in-line "Ir a la letra en la linea actual...")
      ("v" avy-goto-char "Ir a la palabra (2)..."))
    (bind-key "C-z" 'hydra-avy/body)
    ;; Hydra nos permite hacer magia con la administración de ventanas dentro de
    ;; un marco de Emacs. Varios paquetes estan especificados en el `:preface'
    ;; del macro para hydra
    (defhydra hydra-win (:columns 4 :color amaranth :pre (progn (golden-ratio-mode -1) (balance-windows)) :post (progn (golden-ratio-mode 1) (golden-ratio-adjust golden-ratio-adjust-factor)))
      "Manejo de ventanas"
      ("<up>" windmove-up "Cursor ↑")
      ("<left>" windmove-left "Cursor ←")
      ("<down>" windmove-down "Cursor ↓")
      ("<right>" windmove-right "Cursor →")
      ("C-<up>" hydra-move-splitter-up "Astilla ↑")
      ("C-<left>" hydra-move-splitter-left "Astilla ←")
      ("C-<down>" hydra-move-splitter-down "Astilla ↓")
      ("C-<right>" hydra-move-splitter-right "Astilla →")
      ("b" shackra/switch-buffer "Cambiar buffer")
      ("f" shackra/find-file "Visitar/Crear archivo")
      ("z" (lambda () (interactive) (ace-window 1) (add-hook 'ace-window-end-once-hook 'hydra-win/body)) "Mover cursor a otra ventana")
      ("2" (lambda () (interactive) (split-window-right) (windmove-right)) "Dividir |")
      ("3" (lambda () (interactive) (split-window-below) (windmove-down)) "Dividir -")
      ("c" (lambda () (interactive) (ace-window 4) (add-hook 'ace-window-end-once-hook 'hydra-win/body)) "Intercambiar buffer de ventana")
      ("s" save-buffer "Guardar buffer")
      ("x" delete-window "Borrar ventana")
      ("X" (lambda () (interactive) (ace-window 16) (add-hook 'ace-window-end-once-hook 'hydra-win/body)) "Borrar esta/otra ventana")
      ("1" ace-maximize-window "Maximizar esta ventana")
      ("," (progn (winner-undo) (setf this-command 'winner-undo)) "Deshacer ultimo cambio")
      ("." winner-redo "Rehacer ultimo cambio")
      ("SPC" nil "Salir"))
    (bind-key "M-1" #'hydra-win/body))
#+END_SRC
*** dired
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:45]
:END:
Manejador de archivos de serie para Emacs.

Algunas mejoras fueron sacadas de [[https://truongtx.me/2013/04/24/dired-as-default-file-manager-1-introduction/][Dired as Default File Manager - Introduction]].
#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :init
    (setf ranger-cleanup-eagerly t))
  (use-package dired+
    :init
    (diredp-toggle-find-file-reuse-dir 1))
  (use-package dired-details+
    ;; Sólo activa este paquete en caso de que la versión de Emacs no sea mayor
    ;; a 24.4.
    :if (version< emacs-version "24.4")
    :init
    (setf dired-details-propagate-flag t
          dired-details-initially-hide nil))
  ;; -*- lexical-binding: t -*-
  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
                ("[" . multi-term)
                ("," . dired-omit-mode)
                ("e" . ora-ediff-files)
                ("c" . dired-do-compress-to) ;; Necesita Emacs 25.x
                )
    :init
    (setq-default dired-omit-mode t)
    (setq-default dired-omit-files "^\\.?#\\|^\\.$\\|^\\.")
    (setq-default dired-omit-verbose nil)
    (setf dired-dwim-target t)
    (defun shackra/dired-no-esconder-detalles ()
      "No esconder los detalles de los archivos en dired, se ven muy bien"
      (dired-hide-details-mode 0))
    (defun dired-sort-group-dirs ()
      "Sort dired listings with directories first."
      (save-excursion
        (let (buffer-read-only)
          (forward-line 2) ;; beyond dir. header
          (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
        (set-buffer-modified-p nil)))
    ;; extraído de https://oremacs.com/2017/03/18/dired-ediff/
    (defun ora-ediff-files ()
      (interactive)
      (let ((files (dired-get-marked-files))
            (wnd (current-window-configuration)))
        (if (<= (length files) 2)
            (let ((file1 (car files))
                  (file2 (if (cdr files)
                             (cadr files)
                           (read-file-name
                            "Archivo: "
                            (dired-dwim-target-directory)))))
              (if (file-newer-than-file-p file1 file2)
                  (ediff-files file2 file1)
                (ediff-files file1 file2))
              (add-hook 'ediff-after-quit-hook-internal
                        (lambda ()
                          (setq ediff-after-quit-hook-internal nil)
                          (set-window-configuration wnd))))
          (error "Más de 2 archivos no deberían ser marcados"))))
    (with-eval-after-load 'dired-aux
      ;; registra 7zip para compresión de archivos.
      (add-to-list 'dired-compress-files-alist '("\\tar\\.7z\\'" . "tar cf - %i | 7z a -si -m0=lzma2 -mx=3 %o.tar.7z")))
    :config
    (add-hook 'dired-mode-hook 'shackra/dired-no-esconder-detalles)
    (defadvice dired-readin
        (after dired-after-updating-hook first () activate)
      "Sort dired listings with directories first before adding marks."
      (dired-sort-group-dirs)))
#+END_SRC
*** =keyfreq=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:45]
:END:
Registra la frecuencia con la que se usan ciertas teclas en Emacs. Esta información se puede utilizar para saber a qué comandos dar combinaciones de teclas más fáciles de presionar.
#+BEGIN_SRC emacs-lisp
  (use-package keyfreq
    :if (daemonp)
    :config
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+END_SRC
**** ¿Cómo procesar la información estadística obtenida por éste paquete?
Primero se ejecuta el comando =command-frequency-display= el cual popula un buffer con los datos, el contenido de ese buffer debe ser guardado en un archivo. Luego se usa un [[http://ergoemacs.org/emacs/command-frequency.py][script de Python]] que procesara ese archivo, saneara los datos y creara un archivo HTML el cual contendrá el reporte.
*** =undo-tree=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:45]
:END:
Comando asociado a @@html:<kbd>C-x u</kbd>@@.

Reemplaza el mecanismo de deshacer/hacer de Emacs con un sistema que trata los cambios realizados como un árbol con ramificaciones.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    ;; Reemplaza el mecanismo de deshacer/hacer de Emacs con un sistema que trata
    ;; los cambios realizados como un árbol con ramificaciones de cambios.
    ;; para revertir un cambio use `C-x u'. Más información en:
    ;;   http://melpa.milkbox.net/#/undo-tree
    :demand t
    :diminish undo-tree-mode
    :bind (:map
           undo-tree-visualizer-mode-map ("RET" . undo-tree-visualizer-quit)
           :map
           global-map ("C-x u" . undo-tree-visualizer))
    :init
    (defadvice undo-tree-make-history-save-file-name
        (after undo-tree activate)
      (setq ad-return-value (concat ad-return-value ".7z")))
    (defadvice undo-tree-visualize (around undo-tree-split-side-by-side activate)
      "Divide la ventana de lado a lado al visualizar undo-tree-visualize"
      (let ((split-height-threshold nil)
            (split-width-threshold 0))
        ad-do-it))
    (setf undo-tree-visualizer-timestamps t)
    (setf undo-tree-visualizer-diff t)
    (setf undo-tree-auto-save-history nil) ;; no salva el historial de cambios
    :config
    (defalias 'redo 'undo-tree-redo)
    (global-undo-tree-mode 1))
#+END_SRC
*** zenburn
#+BEGIN_SRC emacs-lisp
  (use-package zenburn-theme
    :config
    (load-theme 'zenburn t))
#+END_SRC
*** numero de lineas
Muestra el numero de lineas al margen del buffer, sea con native-linum (emacs 26+) o con nlinum.
#+BEGIN_SRC emacs-lisp
  (use-package nlinum
    :if (version< emacs-version "26")
    :pin gnu
    :init
    (defun ancho-nlinum-mode-hook ()
      "Calcula el ancho de los números para evitar feos saltos al desplazarse"
      (when nlinum-mode
        (setq-local nlinum-format (concat "%" (number-to-string
                                               (ceiling (log (max 1 (/ (buffer-size) 80)) 10)))
                                          "d"))))
    (defun initialize-nlinum (&optional frame)
      "Flanque de error en nlinum al usar Emacs como demonio"
      (require 'nlinum)
      (add-hook 'prog-mode-hook 'nlinum-mode))
    (add-hook 'nlinum-mode-hook #'ancho-nlinum-mode-hook)
    (if (daemonp)
        (progn
          (add-hook 'window-setup-hook #'initialize-nlinum)
          (defadvice make-frame (around toggle-nlinum-mode compile activate)
            (nlinum-mode -1) ad-do-it (nlinum-mode 1)))
      (add-hook 'prog-mode-hook #'nlinum-mode)))

  (use-package native-linum
    :ensure nil
    :no-require t
    :if (version= emacs-version "26")
    ;; TODO: ver como se activa native-linum
    )
#+END_SRC
*** =company=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:50]
:END:
Un mejor motor de autocompletado comparado con [[https://github.com/auto-complete/auto-complete][auto-complete/auto-complete]].
#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :init
    (setf company-backends '((company-files
                              company-keywords
                              company-capf
                              company-yasnippet)
                             (company-abbrev company-dabbrev)))
    (setf company-idle-delay 0.5)
    (setf company-tooltip-limit 10)
    (setf company-minimum-prefix-length 1)
    (setf company-echo-delay 0)
    (setf company-auto-complete nil)
    (add-hook 'after-init-hook #'global-company-mode))
#+END_SRC
=company-statistics= ofrece mejores predicciones en sus resultados de acuerdo a datos estadísticos.
#+BEGIN_SRC emacs-lisp
  (use-package company-statistics
    :after (company)
    :init
    (setf company-statistics-file "~/.company-statistics-cache.el")
    (add-hook 'after-init-hook 'company-statistics-mode))
#+END_SRC
=company-quickhelp= genera mejores popups que Emacs para visualizar documentación de funciones/variables.
#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :after (company)
    :config (company-quickhelp-mode 1))
#+END_SRC
*** company-auctex
backend para [[*=company=][Company]] que provee auto completado para AUCTeX
#+BEGIN_SRC emacs-lisp
  (use-package company-auctex
    :after (auctex company)
    :config
    (company-auctex-init))
#+END_SRC
*** =projectile=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:50]
:END:
Manejo de archivos de un proyecto.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init
    (setf projectile-completion-system 'ivy
          projectile-switch-project-action 'counsel-projectile-find-file)
    (setf
     projectile-file-exists-remote-cache-expire (* 10 60)
     projectile-globally-ignored-files '("TAGS" "\#*\#" "*~" "*.la"
                                         "*.o" "*.pyc" "*.elc" "*.exe"
                                         "*.zip" "*.tar.*" "*.rar" "*.7z"))
    :config
    (add-hook 'after-init-hook #'projectile-global-mode))

  (use-package ag)
#+END_SRC
*** =recentf=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:51]
:END:
Archivos recientes abiertos en Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :ensure nil
    :init
    (setf recentf-max-saved-items 100)
    :config
    (add-to-list 'recentf-exclude ".git/")
    (add-to-list 'recentf-exclude ".hg/")
    (add-to-list 'recentf-exclude "elpa/")
    (add-to-list 'recentf-exclude "\\.emacs.d/org-clock-save.el\\'")
    (add-to-list 'recentf-exclude "INBOX/"))
#+END_SRC
*** =expand-region=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:51]
:END:
Incrementa la selección por unidades semánticas. Asociado a @@html:<kbd>C-c 0</kbd>@@
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind ("C-c 0" . er/expand-region))
#+END_SRC
*** =avy-jump=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:51]
:END:
El cursor salta en cualquier parte del buffer según un /árbol de decisiones/ basado en caracteres. Asociado a @@html:<kbd>C-c z</kbd>@@
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :defer 3
    :config
    (bind-keys :prefix-map shackra/avy-mode-map
               :prefix "C-c z"
               ("z" . avy-goto-line)
               ("x" . avy-goto-word-1)
               ("c" . avy-goto-char-in-line)
               ("v" . avy-goto-char)))
#+END_SRC
*** =multi-term=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:51]
:END:
Ofrece un excelente emulador de terminal *dentro* de Emacs. Asociado a @@html:<kbd><f1></kbd>@@
#+BEGIN_SRC emacs-lisp
  (use-package multi-term
    :bind ([f1] . multi-term)
    :init
    (defun shackra/maybe-disable-yasnippet ()
      "Desactiva yasnippet a pedido"
      (if (fboundp 'yas-minor-mode)
          (yas-minor-mode -1)))
    (defun shackra/term-line-or-char-mode ()
      "Cambia entre `term-line-mode' y `term-char-mode'"
      (interactive)
      (when (string= (buffer-local-value 'major-mode (current-buffer)) "term-mode")
        (if (term-in-char-mode)
            (term-line-mode)
          (term-char-mode))))
    :config
    (setf multi-term-buffer-name "sh-"
          multi-term-program "/usr/bin/zsh"
          multi-term-program-switches "--login")
    (add-to-list 'term-bind-key-alist '("C-c C-c"   . term-interrupt-subjob))
    (add-to-list 'term-bind-key-alist '("C-p"       . previous-line))
    (add-to-list 'term-bind-key-alist '("C-n"       . next-line))
    (add-to-list 'term-bind-key-alist '("M-f"       . term-send-forward-word))
    (add-to-list 'term-bind-key-alist '("M-b"       . term-send-backward-word))
    (add-to-list 'term-bind-key-alist '("C-c C-j"   . shackra/term-line-or-char-mode))
    (add-to-list 'term-bind-key-alist '("C-DEL"     . term-send-backward-kill-word))
    (add-to-list 'term-bind-key-alist '("M-d"       . term-send-forward-kill-word))
    (add-to-list 'term-bind-key-alist '("<C-left>"  . term-send-backward-word))
    (add-to-list 'term-bind-key-alist '("<C-right>" . term-send-forward-word))
    (add-to-list 'term-bind-key-alist '("C-r"       . term-send-reverse-search-history))
    (add-to-list 'term-bind-key-alist '("M-p"       . term-send-raw-meta))
    (add-to-list 'term-bind-key-alist '("M-y"       . term-send-raw-meta))
    (add-to-list 'term-bind-key-alist '("C-y"       . term-paste))

    (add-hook 'term-mode-hook #'shackra/maybe-disable-yasnippet))
#+END_SRC
*** =git=
#+BEGIN_SRC emacs-lisp
  (use-package gitignore-mode)
  (use-package gitconfig-mode)
#+END_SRC
*** =magit=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:51]
:END:
Git en Emacs. A decir verdad, amo Mercurial y odio Git. Usar @@html:<kbd>C-c p v</kbd>@@ de =projectile= para invocarlo.
#+BEGIN_SRC emacs-lisp
  (use-package magit-gh-pulls
    :after (magit)
    :config
    (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls))
  (use-package magit
    :defer t
    :after (yasnippet s)
    :init
    (defun shackra/git-commit-message-setup ()
      "Quita la plantilla e inserta un snippet"
      ;; Busca la región correspondiente a la plantilla de los commits
      (yas-minor-mode-on)
      (remove-hook 'git-commit-setup-hook 'yas-reload-all)
      (search-forward "# Please enter the commit message for your changes." nil t)
      (search-backward "\n\n#" nil t)
      ;; Elimina la región anterior, inserta y expande un snippet de YaSnippet
      (yas-expand-snippet (yas-lookup-snippet "git plantilla" 'text-mode t) (point-min) (point)))
    (defun shackra/git-commit-lint-summary (str)
      "Capitaliza y quita puntos finales del sumario `STR'"
      (interactive)
      (when (stringp str)
        (let* ((str (substring-no-properties str))
               (first-word (car (split-string str " ")))
               (sentence-capitalized (s-replace first-word (s-capitalize first-word) str)))
          (while (string-suffix-p "." sentence-capitalized)
            (setf sentence-capitalized (string-remove-suffix "." sentence-capitalized)))
          sentence-capitalized)))
    (add-hook 'git-commit-setup-hook #'yas-reload-all)
    ;; (add-hook 'git-commit-setup-hook #'shackra/git-commit-message-setup t)
    (setf magit-last-seen-setup-instructions "1.4.0"
          magit-auto-revert-mode t
          magit-completing-read-function 'ivy-completing-read))
#+END_SRC
*** git-gutter-fring
Muestra información de =git diff= en el fringe.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe
    :diminish git-gutter-mode
    :config
    (global-git-gutter-mode t))
#+END_SRC
*** =monky=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:51]
:END:
Mercurial en Emacs. Amo Mercurial ;). Asociado a @@html:<kbd><C-f12></kbd>@@

Ver opciones más actualizadas para Mercurial en [[https://www.reddit.com/r/emacs/comments/3nzp7a/best_way_to_use_mercurial_with_emacs/][Best way to use Mercurial with Emacs? : emacs]]
#+BEGIN_SRC emacs-lisp
  (use-package monky
    :defer t
    :bind ([C-f12] . monky-status)
    :init
    (setf monky-process-type 'cmdserver))

  (use-package hgignore-mode)
#+END_SRC
*** =kill-or-bury-alive=
Permite designar qué buffers queremos matar o enterrar (/bury/). Asociado a @@html:<kbd>C-x k</kbd>@@
#+BEGIN_SRC emacs-lisp
  (use-package kill-or-bury-alive
    :bind (("C-x k" . kill-or-bury-alive))
    :config
    (setf kill-or-bury-alive-must-die-list
          '("^\\*Calendar\\*$" "^\\*Help\\*$" "^\\*Packages\\*$" dired-mode prog-mode text-mode rust-mode fundamental-mode weechat-mode "^\\*Backtrace\\*$"))
    (add-to-list 'kill-or-bury-alive-long-lasting-list "^\\*sh-<[:digit:]+>\\*$" t))
#+END_SRC
*** eldoc
Muestra en el =área de eco= la firma de la función actual.
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :ensure nil
    :diminish eldoc-mode
    :init
    (setf eldoc-idle-delay 1.0))
#+END_SRC
*** =auto-revert-mode=
Revierte el contenido de un buffer de manera automática cuando el contenido de un archivo a cambiado fuera de Emacs
#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :ensure nil
    :init
    (global-auto-revert-mode))
#+END_SRC
*** YASnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :init
    (defun shackra/yas-reload ()
      "Recarga las definiciones de YaSnippet una vez"
      (yas-reload-all)
      (remove-hook 'after-init-hook 'shackra/yas-reload))
    :config
    (setq yas-snippet-dirs (append yas-snippet-dirs (list (expand-file-name "plantillas" user-emacs-directory))))
    (add-hook 'prog-mode-hook #'yas-minor-mode-on)
    (add-hook 'after-init-hook #'shackra/yas-reload))
#+END_SRC
*** imenu-anywhere
Crea menús a partir de secciones de documentos. Asociado a @@html:<kbd>C-c i</kbd>@@
#+BEGIN_SRC emacs-lisp
  (use-package imenu-anywhere
    :config
    (bind-key "C-c i" 'ivy-imenu-anywhere))
  (use-package imenu+
    :disabled ;; ver razón en https://redd.it/3ahj2d
    :init
    (setf imenup-ignore-comments-flag t))

#+END_SRC
*** Bookmark+
Marcadores para varias cosas en Emacs, asociado a @@html:<kbd>M-p</kbd>@@
#+BEGIN_SRC emacs-lisp
  (use-package bookmark
    :ensure nil
    :init
    (setf bookmark-default-file "~/.emacs.d/bookmarks")
    (setf bookmark-save-flag 1))

  (use-package bookmark+
    :init
    (setf bmkp-auto-light-when-set 'all-in-buffer)
    (setf bmkp-last-as-first-bookmark-file bookmark-default-file)
    :bind (("C-c b" . hydra-bm/body))
    :config
    (defhydra hydra-bm (:color amaranth :hint nil)
      "
      Marcadores

      Cambiar                          Agregar           Editar
    ╭──────────────────────────────────────────────────────────────────────╯
     [_j_] Anterior (buffer actual)   [_f_] aquí...   [_e_] aquí...
     [_l_] Siguiente (buffer actual)  [_F_] archivo
     [_k_] Saltar a...
     [_K_] Saltar a... (por tipo)
     [_i_] Saltar a... (otra vent.)
    -----------------------------------------------------------------------
  "
      ("j" bmkp-previous-bookmark-this-buffer)
      ("l" bmkp-next-bookmark-this-buffer)
      ("k" bmkp-jump-in-navlist :color blue)
      ("K" bmkp-jump-to-type :color blue)
      ("i" bmkp-jump-to-type-other-window :color blue)
      ("f" bmkp-bookmark-set-confirm-overwrite :color blue)
      ("F" bmkp-file-target-set :color blue)
      ("e" bmkp-edit-bookmark-name-and-location :color blue)
      ("L" bookmark-bmenu-list "Menú de marcadores" :color blue)
      ("<ESC>" nil "Salir")))
#+END_SRC
*** Firefox desde Emacs
#+BEGIN_SRC emacs-lisp
  (use-package moz-controller)
#+END_SRC
*** Chrome desde Emacs
#+BEGIN_SRC emacs-lisp
  (use-package kite-mini
    :disabled
    :after (simple-httpd)
    :init
    (defun shackra/webdev-refresh-page-on-save-chrome ()
      "Refresca la pagina en Chrome para ver los cambios realizados"
      (interactive)
      (let* ((currentfiledir (file-name-directory (buffer-file-name)))
             (inrootdir (string-suffix-p httpd-root currentfiledir)))
        (when (and (derived-mode-p 'sgml-mode 'css-mode 'web-mode) inrootdir)
          (kite-mini-reload))
        (when (and (derived-mode-p 'js-mode 'js2-mode) inrootdir)
          (kite-mini-update))))
    (add-hook 'js2-mode-hook (lambda () (kite-mini-mode t)))
    (add-hook 'css-mode-hook (lambda () (kite-mini-mode t)))
    (add-hook 'sgml-mode-hook (lambda () (kite-mini-mode t)))
    (add-hook 'after-save-hook #'shackra/webdev-refresh-page-on-save-chrome))
#+END_SRC
*** iedit
Edita varias ocurrencias de un texto en el buffer.

Teclas:
- M-H :: iedit-restrict-function
- M-I :: iedit-restrict-current-line
- M-{ :: iedit-expand-up-a-line
- M-} :: iedit-expand-down-a-line
- M-p :: iedit-expand-up-to-occurrence
- M-n :: iedit-expand-down-to-occurrence
- M-G :: iedit-apply-global-modification
- M-C :: iedit-toggle-case-sensitive
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :bind (:map
           iedit-mode-keymap ("RET" . iedit-quit)
           :map
           global-map ("C-'" . iedit-mode)))
#+END_SRC
** Comunicación
*** prodigy
Corre procesos externos a Emacs de manera automática
#+BEGIN_SRC emacs-lisp
  (use-package prodigy
    :disabled
    :if (daemonp)
    :init
    (prodigy-define-tag
      :name 'email
      :ready-message "Checking Email using IMAP IDLE. Ctrl-C to shutdown.")
    (prodigy-define-service
      :name "goimapnotify"
      :command "goimapnotify"
      :args (list "-conf" (expand-file-name ".config/imapnotify/jorge.conf.private" (getenv "HOME")))
      :tags '(email)
      :kill-signal 'sigkill)
    (prodigy-start-service (car prodigy-services)))
#+END_SRC
*** =mu4e=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:52]
- Refiled on [2015-11-12 jue 16:51]
:END:
Un versátil cliente de correo electrónico para Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package mu4e-alert
    :if (executable-find "mu")
    :after (mu4e)
    :init
    (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
    (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
    (setq mu4e-alert-email-notification-types '(subjects))
    :config
    (mu4e-alert-set-default-style 'libnotify))

  (use-package org-mu4e
    :after (mu4e org)
    :ensure nil
    :init
    (setq org-mu4e-link-query-in-headers-mode nil))

  (use-package mu4e
    :commands (mu4e correo)
    :ensure nil
    :preface
    ;;; message view action
    (defun mu4e-msgv-action-view-in-browser (msg)
      "Ver el cuerpo del mensaje HTML en el navegador web"
      (interactive)
      (let ((html (mu4e-msg-field (mu4e-message-at-point t) :body-html))
            (tmpfile (format "%s/%d.html" temporary-file-directory (random))))
        (unless html (error "No hay partes en HTML para este mensaje"))
        (with-temp-file tmpfile
          (insert
           "<html>"
           "<head><meta http-equiv=\"content-type\""
           "content=\"text/html;charset=UTF-8\">"
           html))
        (browse-url (concat "file://" tmpfile))))

    (defadvice mu4e (before mu4e-start activate)
      "Antes de ejecutar `mu4e' borramos todas las ventanas"
      (window-configuration-to-register :mu4e-fullscreen)
      (delete-other-windows))

    (defadvice mu4e-quit (after mu4e-close-and-push activate)
      "Despues de salir de mu4e ejecutamos un script para subir los cambios al buzon de correo y para también restaurar la disposición de ventanas"
      (start-process "pushmail" nil "pushmail.sh")
      (jump-to-register :mu4e-fullscreen))
    :init
    (setf mu4e-get-mail-command "getmail.sh")
    ;; html2text es un paquete que debe estar instalado en tu sistema
    (setf mu4e-html2text-command 'mu4e-shr2text)
    ;; hace mu4e el programa por defecto para escribir correo
    (setq mail-user-agent 'mu4e-user-agent)
    (setf mu4e-confirm-quit nil)
    (setf mu4e-context-policy 'pick-first)
    (setf mu4e-change-filenames-when-moving t)
    (setf mu4e-headers-date-format "%d/%m/%Y %H:%M")
    (setf message-citation-line-format "\nEl %A %d de %B del %Y a las %H%M horas, %N escribió:\n")
    (setf message-citation-line-function 'message-insert-formatted-citation-line)
    (setf message-cite-reply-position 'below)
    (setf mu4e-auto-retrieve-keys t)
    (setf mu4e-headers-leave-behavior 'apply)
    (setf mu4e-headers-visible-lines 8)
    (setf mu4e-hide-index-messages t)
    (setf message-kill-buffer-on-exit t)
    ;; TODO: Modificar esto de manera dinámica para otros sistemas operativos
    (setf mu4e-attachment-dir  "~/Descargas")
    ;; TODO: modificar esto segun sistema operativo?
    (setf mu4e-maildir "~/Mail")
    (setf smtpmail-stream-type  'ssl)
    (setf smtpmail-smtp-service 465)
    (setf message-send-mail-function 'smtpmail-send-it)
    (setf mu4e-bookmarks
          '(("flag:unread" "No leido" ?n)
            ("flag:flagged" "Marcados como importantes" ?m)
            ("maildir:/personal/Drafts OR maildir:/personal/Borradores" "Borradores" ?b)))
    (setf user-mail-address "jorge@esavara.cr")
    (setf smtpmail-smtp-server "mail.privateemail.com")
    (setf smtpmail-smtp-user "jorge@esavara.cr")
    (setf mu4e-sent-folder "/personal/Sent")
    (setf mu4e-drafts-folder "/personal/Drafts")
    (setf mu4e-trash-folder "/personal/Trash")
    (setf mu4e-refile-folder "/personal/INBOX/Archive")
    (setf user-full-name "Jorge Javier Araya Navarro")
    (setf mu4e-compose-signature (concat
                                  "👋 Pax et bonum.\n"
                                  "Jorge Javier Araya Navarro\n"
                                  "http://www.esavara.cr"))
    (setf mu4e-maildir-shortcuts '(("/personal/INBOX" . ?p)
                                   ("/personal/INBOX/Archive" . ?A)
                                   ("/personal/Trash" .?t)))
    :config
    (require 'mu4e-contrib)
    (defalias 'correo 'mu4e)
    (add-to-list 'mu4e-view-actions
                 '("navegador web" . mu4e-msgv-action-view-in-browser) t)
    (bind-key "C-c c" 'org-mu4e-store-and-capture mu4e-headers-mode-map)
    (bind-key "C-c c" 'org-mu4e-store-and-capture mu4e-view-mode-map))
#+END_SRC
*** =twittering-mode=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:53]
:END:
Twitter desde Emacs
#+BEGIN_SRC emacs-lisp
  (use-package twittering-mode
    :init
    (defalias 'tt 'twit)
    (setf twittering-use-master-password t)
    (setf twittering-display-remaining t)
    (setf twittering-icon-mode t)
    (setf twittering-timer-interval 300)
    (setf twittering-url-show-status nil)
    :config
    (defun shackra/tt-fav-rett (&optional arg)
      "Marca como favorito y retweetea un tweet"
      (interactive "P")
      (my/bypass-confirmation-all #'twittering-retweet t)
      (my/bypass-confirmation-all #'twittering-favorite))
    (bind-key "C-c f" 'twittering-favorite twittering-mode-map)
    (bind-key "C-c F" 'shackra/tt-fav-rett twittering-mode-map)

    (add-hook 'twittering-edit-mode-hook #'ispell-minor-mode)
    (add-hook 'twittering-edit-mode-hook #'flyspell-mode))
#+END_SRC
*** =sx=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:53]
:END:
Acceso a Stackoverflow y subsitios desde Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package sx
    :defer 10)
#+END_SRC
*** org2web
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:57]
- Refiled on [2015-11-12 jue 16:46]
:END:
Generador estático de sitios web que depende de Emacs, Git y Org-mode.
#+BEGIN_SRC emacs-lisp
  (use-package org2web
    :after (el2org ox-gfm)
    :config
    ;; Le pedimos a org-mode que no meta las patas cuando exporta archivos a
    ;; HTML. Nosotros manejaremos el marcado de sintaxis de código fuente.
    ;; Muchas gracias a Chen Bin[1] por los trozos de código[2] sacados de su
    ;; propio proyecto[3] :)
    ;;
    ;; [1]: http://emacs.stackexchange.com/users/202/chen-bin
    ;; [2]: http://emacs.stackexchange.com/a/9839/690
    ;; [3]: https://github.com/redguardtoo/org2nikola/blob/master/org2nikola.el
    (load-file (expand-file-name "srcprecode.el" user-emacs-directory))
    (org2web-add-project '("El blog de Shackra"
                           :repository-directory "~/Documentos/elblog.deshackra.com/"
                           :ignore-file-name-regexp "README"
                           :remote (rclone "rscf" "elblog.deshackra.com")
                           :site-domain "http://elblog.deshackra.com"
                           :site-main-title "El blog de Shackra"
                           :site-sub-title "No seas tan abierto de mente o tu cerebro se caerá"
                           :theme-root-directory (:eval (list (expand-file-name "org-page-themes" user-emacs-directory)))
                           :theme (shackra)
                           :source-browse-url ("Bitbucket" "https://bitbucket.org/shackra/blog")
                           :confound-email t
                           :default-category "blog"
                           :about ("Sobre mi" "/about")
                           :rss ("RSS" "/rss.xml")
                           :summary (("etiquetas" :tags))
                           :source-browse-url ("Bitbucket" "https://bitbucket.org/shackra/blog/")
                           :web-server-docroot "~/Documentos/deshackra.com/elblog.deshackra.com"
                           :web-server-port 5777))

    (eval-after-load 'ox
      '(progn
         (add-to-list 'org-export-filter-src-block-functions
                      'org2html-wrap-blocks-in-code))))
  (use-package el2org)
  (use-package ox-gfm)
#+END_SRC
*** mediawiki
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:58]
- Refiled on [2015-11-12 jue 16:53]
:END:
Interfaz para editar paginas en instancias de Mediawiki desde Emacs. [[http://wikemacs.org/wiki/Mediawiki.el][Mediawiki.el - WikEmacs]]
#+BEGIN_SRC emacs-lisp
  (use-package mediawiki
    :disabled
    :init
    (setf mediawiki-site-alist '(("Wikipedia en español" "https://es.wikipedia.org/w/" "" "" "Portal:Iglesia_católica")
                                 ("Wikipedia en Inglés" "https://en.wikipedia.org/w/" "" "" "Portal:Catholicism")
                                 ("Parabola GNU/Linux-libre" "https://wiki.parabola.nu/" "" "" "User:Shackra")
                                 ("Wikemacs" "http://wikemacs.org/" "" "" "User:Shackra")))
    (setf mediawiki-site-default "Wikemacs")
    :config
    (add-hook 'mediawiki-mode-hook '(lambda ()
                                      (turn-off-auto-fill)
                                      (visual-line-mode 1))))
#+END_SRC
*** Weechat
Conexión a Weechat desde Emacs
#+BEGIN_SRC emacs-lisp
  (use-package weechat
    :if (executable-find "weechat")
    :config
    (add-to-list 'weechat-modules 'weechat-spelling)
    (add-hook 'after-init-hook (lambda () (when (not (weechat-connected-p))
                                       (weechat-connect weechat-host-default weechat-port-default "xxx" 'plain)))))
#+END_SRC
*** Slack
#+BEGIN_SRC emacs-lisp
  (use-package color)
  (use-package slack
    :init
    (setq slack-buffer-emojify t)
    (setq slack-prefer-current-team t)
    :config
    (slack-register-team
     :name "brete"
     :default t
     :client-id "15969776599.285906366548"
     :client-secret (secrets-get-secret "login" "emacs-slack-brete client-secret")
     :token (secrets-get-secret "login" "emacs-slack-brete password")
     :subscribed-channels '(general development-coding))
    (slack-register-team
     :name "American Chesterton Society Slack"
     :client-id "108268788771.277619878759"
     :client-secret (secrets-get-secret "login" "emacs-slack client-secret")
     :token (secrets-get-secret "login" "emacs-slack password")
     :subscribed-channels '(general))
    (slack-start))
#+END_SRC
*** Redmine
#+BEGIN_SRC emacs-lisp
  (use-package org-redmine
    :init
    (setq org-redmine-uri "https://my.ivrtechnology.com")
    (setq org-redmine-auth-api-key (secrets-get-secret "login" "brete redmine")))
#+END_SRC
** Desarrollo de software
*** org-babel
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (shell . t)))
#+END_SRC
*** =prog-mode=
Cualquier modo mayor que /herede/ de =prog-mode= sera afectado por esta configuración.
#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers)
  (use-package highlight-escape-sequences
    :config
    (put 'hes-escape-backslash-face 'face-alias 'font-lock-builtin-face)
    (put 'hes-escape-sequence-face 'face-alias 'font-lock-builtin-face))
  (use-package rainbow-mode)
  (use-package prog-mode
    :ensure nil
    :init
    (defun shackra/prog-mode ()
      (set (make-local-variable 'fill-column) 79)
      (set (make-local-variable 'comment-auto-fill-only-comments) t)
      ;; Nota: M-q rellena las columnas del párrafo actual
      ;;       M-o M-s centra una linea de texto
      (auto-fill-mode t)
      (highlight-numbers-mode)
      (hes-mode)
      (electric-pair-mode)
      (rainbow-turn-on)
      (when (or (executable-find "ispell") (executable-find "hunspell"))
        (flyspell-prog-mode)))
    (bind-key "RET" 'newline-and-indent prog-mode-map)
    (bind-key* "C-M-," 'comment-dwim)
    (add-hook 'prog-mode-hook #'shackra/prog-mode))
#+END_SRC
*** =org-mode=                                                      :nuevo:
El modo Org (Org-mode) es un modo de edición del editor de texto Emacs mediante el cual se editan documentos jerárquicos en texto plano.

Su uso encaja con distintas necesidades, como la creación de notas de cosas por hacer, la planificación de proyectos y hasta la escritura de páginas web. Por ejemplo, los elementos to-do (cosas por hacer) pueden disponer de prioridades y fechas de vencimiento, pueden estar subdivididos en subtareas o en listas de verificación, y pueden etiquetarse o dársele propiedades. También puede generarse automáticamente una agenda de las entradas de cosas por hacer. ~[[https://es.wikipedia.org/wiki/Org-mode][org-mode - Wikipedia, la enciclopedia libre]]

Teclas
- @@html:<kbd>C-c l</kbd>@@ :: Guardar enlace a cosa
- @@html:<kbd>C-c a</kbd>@@ :: Abre la agenda
- @@html:<kbd>C-c c</kbd>@@ :: Capturar algo
#+BEGIN_SRC emacs-lisp
  (use-package org-download
    :init
    (setq-default org-download-image-dir "~/org/imagenes/"))

  (use-package org
    :bind (:map global-map
                ("C-c a" . org-agenda)
                ("<F12>" . org-agenda)
                ("C-c l" . org-store-link)
                ("C-c c" . org-capture))
    :init
    (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXAMPLE"))
    ;; Exclude DONE state tasks from refile targets
    (defun verify-refile-target ()
      "Exclude todo keywords with a done state from refile targets"
      (not (member (nth 2 (org-heading-components)) org-done-keywords)))
    (setf org-refile-target-verify-function #'verify-refile-target)
    (defun air-org-skip-subtree-if-priority (priority)
      "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY may be one of the characters ?A, ?B, or ?C."
      (let ((subtree-end (save-excursion (org-end-of-subtree t)))
            (pri-value (* 1000 (- org-lowest-priority priority)))
            (pri-current (org-get-priority (thing-at-point 'line t))))
        (if (= pri-value pri-current)
            subtree-end
          nil)))
    (defun air-org-skip-subtree-if-habit ()
      "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (string= (org-entry-get nil "STYLE") "habit")
            subtree-end
          nil)))
    (defun shackra-org-clocktable-formatter (ipos tables params)
      "Extrae el titulo de enlaces y elimina TODO keywords"
      (cl-loop for tbl in tables
               for entries = (nth 2 tbl)
               do (cl-loop for entry in entries
                           for headline = (nth 1 entry)
                           do (setq headline (replace-regexp-in-string (shackra--org-clocktable-regexp) "" headline))
                           do (when (string-match-p "\\[\\[.*\\]\\[\\(.*\\)\\]\\]" headline) (setf headline (replace-regexp-in-string "\\[\\[.*\\]\\[\\(.*\\)\\]\\]" "\\1" headline)))
                           do (setcar (nthcdr 1 entry) headline)))
      (org-clocktable-write-default ipos tables params))

    (defun shackra--org-clocktable-regexp ()
      "Genera una expresion regular a partir de la variable `org-todo-keywords'"
      (let ((regexp)
            (flat (shackra--flatten org-todo-keywords)))
        (dolist (e flat)
          (when (and (stringp e) (not (string-match-p "|" e)) (not (string-empty-p e)))
            (append regexp (replace-regexp-in-string "(.*)" " " e))))
        (string-join regexp "\\|")))

    (defun shackra--flatten (mylist)
      "Flat an array

  Taken from https://rosettacode.org/wiki/Flatten_a_list#Emacs_Lisp"
      (cond
       ((null mylist) nil)
       ((atom mylist) (list mylist))
       (t
        (append (shackra--flatten (car mylist)) (shackra--flatten (cdr mylist))))))

    (setf org-clock-clocktable-formatter 'shackra-org-clocktable-formatter)
    ;; Targets include this file and any file contributing to the agenda - up to
    ;; 9 levels deep
    (setf org-refile-targets `((nil :maxlevel . 9)
                               (org-agenda-files :maxlevel . 9)
                               (org-default-notes-file :maxlevel . 9)
                               (,(expand-file-name "notas.org" org-directory) :maxlevel . 9)
                               (,(expand-file-name "quizas.org" org-directory) :maxlevel . 9)))
    (setf org-clock-modeline-total 'today)
    ;; Use full outline paths for refile targets
    (setq org-refile-use-outline-path 'file)

    (setq org-outline-path-complete-in-steps t)

    ;; Allow refile to create parent tasks with confirmation
    (setq org-refile-allow-creating-parent-nodes 'confirm)

    (setf org-directory "~/org/")
    ;; evita dividir una linea con M-RET
    (setf org-M-RET-may-split-line '((default . nil)))
    (setf org-default-notes-file (expand-file-name "notas.org" org-directory)
          org-agenda-files (list (expand-file-name "cosas por hacer.org" org-directory)))
    (setf org-todo-keywords
          '((sequence "POR-HACER(p)" "SIGNT(s)" "|" "TERMINADO(t)")
            (sequence "ESPERA(e@/!)" "RETENER(r@/!)" "|" "CANCELADO(c@/!)")))
    (setf org-todo-keyword-faces
          '(("POR-HACER" :foreground "red" :weight bold)
            ("SIGNT" :foreground "blue" :weight bold)
            ("TERMINADO" :foreground "forest green" :weight bold)
            ("ESPERA" :foreground "orange" :weight bold)
            ("RETENER" :foreground "magenta" :weight bold)
            ("CANCELADO" :foreground "forest green" :weight bold)))
    (setf org-use-fast-todo-selection t)
    (setf org-treat-S-cursor-todo-selection-as-state-change nil)
    (setf org-todo-state-tags-triggers
          '(("CANCELADO" ("CANCELADO" . t))
            ("ESPERA" ("ESPERA" . t))
            ("RETENER" ("ESPERA") ("RETENER" . t))
            (done ("ESPERA") ("RETENER"))
            ("POR-HACER" ("ESPERA") ("CANCELADO") ("RETENER"))
            ("SIGNT" ("ESPERA") ("CANCELADO") ("RETENER"))
            ("TERMINADO" ("ESPERA") ("CANCELADO") ("RETENER"))))
    ;; según http://orgmode.org/manual/Link-abbreviations.html#Link-abbreviations
    (setf org-link-abbrev-alist
          '(("rarbg" . "https://rarbg.to/torrents.php?search=%s&category%5B%5D=17&category%5B%5D=18")
            ("nyaa" . "https://www.nyaa.se/?page=search&cats=1_0&filter=0&term=%s")
            ("bakabt" . "https://bakabt.me/browse.php?only=0&incomplete=1&bonus=1&c1=1&c2=1&reorder=1&q=%s")
            ("tokyotosho" . "https://www.tokyotosho.info/search.php?terms=%s&type=1&size_min=&size_max=&username=")))
    (setf org-capture-templates
          '(("t" "Anotacion técnica" entry (file "apuntes tecnicos.org")
             "* %^{titulo o situación} %^g\n\n%?\n- Enlaces de relacionados:\n" :kill-buffer t :clock-in t :clock-resume t)
            ("p" "Tarea por hacer" entry (file+headline "cosas por hacer.org" "Tareas")
             "* POR-HACER %^{breve descripción} %a %^g\n:PROPERTIES:\n:CREATED:%U\n:END:\n%?" :kill-buffer t :clock-in t :clock-resume t)
            ("n" "Notas" entry (file+headline org-default-notes-file "Reorganizar")
             "* %^{breve descripción}\n:PROPERTIES:\n:CREATED:%U\n:END:\n%?" :kill-buffer t :clock-in t :clock-resume t)
            ("f" "Fechas o eventos" entry (file+headline "cosas por hacer.org" "Fechas")
             "* POR-HACER %^{Nombre del evento} %^g\nSCHEDULED: %^T%?\n:PROPERTIES:%(if (yes-or-no-p \"¿Es esto un cumpleaños?\") (format \"\n:NACIMIENTO: %s\" (with-temp-buffer (org-time-stamp nil t) (buffer-string))) \"\")\n:CREATED: %U\n:END:" :kill-buffer t :clock-in t :clock-resume t)
            ("d" "Escribir una nota en el diario" entry (file+datetree "diario.org")
             "* %^{Querido diario...}\n:PROPERTIES:\n:CREATED: %T\n:END:\n%?" :empty-lines 1 :kill-buffer t :clock-in t :clock-resume t)
            ("r" "Receta de cocina" entry (file "recetas.org")
             "* %^{Nombre de la receta}\n:PROPERTIES:\n:CREATED: %T\n:END:\n%?\n%(call-interactively 'org-download-image)\n- Sacado de: %^a\n** Ingredientes\n** Procedimiento"
             :kill-buffer t :clock-in t :clock-resume t)

            ("b" "Bitácora de pendientes")

            ("bp" "Tarea" entry (file+headline "quizas.org" "Cosas por hacer")
             "* %^{breve descripcion}\n:PROPERTIES:\n:CREATED: %U\n:END:\n%?" :kill-buffer t :clock-in t :clock-resume t)
            ("bt" "Aprender" entry (file+headline "quizas.org" "Cosas por hacer")
             "* Aprender sobre %^{cosa}\n:PROPERTIES:\n:CREATED: %T\n:END:\n%?" :kill-buffer t :clock-in t :clock-resume t)
            ("bl" "Libro" entry (file+headline "quizas.org" "Libros")
             "* Leer /%^{Titulo}/ por %^{Autor}\n:PROPERTIES:\n:CREATED: %T\n:AUTOR: %\\2\n:END:\n%?" :kill-buffer t :clock-in t :clock-resume t)
            ("bb" "Blog" entry (file+headline "quizas.org" "Blogs")
             "* Leer entrada de blog /%^{copy as org}/\n:PROPERTIES:\n:CREATED: %T\n:END:\n%\\1%?" :kill-buffer t :clock-in t :clock-resume t)
            ("bx" "Idea de proyecto" entry (file+headline "quizas.org" "Ideas para posibles proyectos")
             "* %^{Titulo o breve descripción} ^%g\n:PROPERTIES:\n:CREATED: %T\n:END:\n%?" :kill-buffer t :clock-in t :clock-resume t)
            ("bm" "Películas" entry (file+headline "quizas.org" "Películas")
             "* Ver [[rarbg:%^{Titulo}][%\\1]]\n:PROPERTIES:\n:CREATED: %T\n:END:" :kill-buffer t :clock-in t :clock-resume t)
            ("ba" "Anime" entry (file+headline "quizas.org" "Anime")
             "* Ver /%^{Anime}/\n:PROPERTIES:\n:CREATED: %T\n:CATEGORY: anime\n:EPISODIO: 1\n:EPISODIOS: %^{numero de episodios}\n:END:\n- [[nyaa:%\\1][Buscar %\\1 en Nyaa Torrents]]\n- [[bakabt:%\\1][Buscar %\\1 en BakaBT]]\n- [[tokyotosho:%\\1][Buscar %\\1 en Tokyo Toshokan]]" :kill-buffer t :clock-in t :clock-resume t)))

    ;; Do not dim blocked tasks
    (setf org-agenda-dim-blocked-tasks nil)

    ;; Compact the block agenda view
    (setf org-agenda-compact-blocks nil)

    ;; Custom agenda command definitions
    (setf org-agenda-custom-commands
          '(("a" "Agenda"
             ((tags "PRIORITY=\"A\""
                    ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                     (org-agenda-overriding-header "Tareas de alta prioridad por terminar:")))
              (agenda ""
                      ((org-agenda-span 'day)
                       (org-agenda-overriding-header "Hoy:")
                       (org-agenda-show-all-dates nil)))
              (agenda ""
                      ((org-agenda-span 'week)
                       (org-agenda-start-day "+1d") ;; A partir de mañana
                       (org-agenda-overriding-header "Semana:")
                       (org-agenda-show-all-dates nil)))
              (agenda ""
                      ((org-agenda-span 'month)
                       ;; A partir de la siguiente semana
                       (org-agenda-start-day "+1w")
                       (org-agenda-overriding-header "Mes:")
                       (org-agenda-show-all-dates nil)))
              (alltodo ""
                       ((org-agenda-skip-function
                         '(or (air-org-skip-subtree-if-habit)
                              (air-org-skip-subtree-if-priority ?A)
                              (org-agenda-skip-if nil '(scheduled deadline))))
                        (org-agenda-overriding-header "Todas las tareas de prioridad normal:")))))))
    (setf org-archive-location (expand-file-name "~/org-archivos/archivado.org::* Entradas viejas y archivadas"))
    (setf org-footnote-auto-adjust t)
    (setf org-outline-path-complete-in-steps nil)
    (setf org-refile-use-outline-path t)
    (setf org-html-htmlize-output-type 'css)
    (setf org-html-htmlize-font-prefix "org-")
    (setf org-habit-graph-column 55)
    (setf org-special-ctrl-k t)
    (setf org-ctrl-k-protect-subtree t) ;; al usar C-k, evitamos perder todo el subarbol
    (setf org-catch-invisible-edits 'show)
    (setf org-return-follow-link t)
    (setf org-startup-indented t)
    (setf org-startup-folded nil)
    (setf org-log-done nil)
    (setf org-log-reschedule 'note)
    (setf org-log-redeadline 'note)
    (setf org-log-note-clock-out nil)
    (setf org-log-refile nil)
    (setf org-log-into-drawer nil)
    (setf org-clock-persist 'history)
    :config
    (org-clock-persistence-insinuate))
  (use-package org-indent
    :after (org)
    :ensure nil
    :diminish org-indent-mode)
  (use-package org-projectile
    :after (org projectile)
    :bind (("C-c p o p" . org-projectile-project-todo-completing-read))
    :init
    (setq org-confirm-elisp-link-function nil)
    :config
    (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
    (add-to-list 'org-capture-templates (org-projectile-project-todo-entry
                                         :capture-character "P"))
    (setf org-agenda-files (append org-agenda-files (org-projectile-todo-files))))
#+END_SRC
*** =org-trello=
Sincroniza archivos org-mode y tableros en Trello
#+BEGIN_SRC emacs-lisp
  (use-package org-trello
    :disabled
    :after (org)
    :init
    (custom-set-variables '(org-trello-files '("/home/jorge/go/src/bitbucket.org/capslockdev/betsy/proyecto.org"
                                               "/home/jorge/Kartelo/clientes/Design Soft/Selore POS/proyecto.org"
                                               "/home/jorge/go/src/bitbucket.org/shackra/4hoa/proyecto.org")))
    (defun shackra/org-trello-sync-after-save ()
      "Sincroniza el contenido del archivo org después de salvar"
      (interactive)
      (when (and (eq major-mode 'org-mode)
               (member buffer-file-name org-trello-files))
        (org-trello-sync-buffer)))
    (add-hook 'after-save-hook #'shackra/org-trello-sync-after-save))
#+END_SRC
*** =pkgbuild-mode=
Un modo mayor de Emacs para la edición de archivos =PKGBUILD=
#+BEGIN_SRC emacs-lisp
  (use-package pkgbuild-mode
    :ensure nil
    :mode "/PKGBUILD$")
#+END_SRC
**** Preparación previa
Si estas en Arch Linux o Parabola GNU/Linux-libre, tienes que instalar el paquete correspondiente desde el repositorio de software de la distribución
#+BEGIN_SRC sh
  sudo pacman -S emacs-pkgbuild-mode
#+END_SRC
*** =python=
Modo mayor para programar en Python
#+BEGIN_SRC emacs-lisp
  (defun python-template ()
    (interactive)
    (insert "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n"))

  (add-hook 'python-mode-hook
            '(lambda () (when (eq (buffer-size) 0) (python-template))))

  (use-package pony-mode
    :after (python)
    :init
    (defun shackra/pony-remove-beautify-html ()
      "Quita el gancho para embellecer el HTML"
      (remove-hook 'before-save-hook 'web-beautify-html-buffer t))
    :config
    ;; quitamos el gancho que embellece el HTML cuando es guardado para que no
    ;; estropeé las plantillas de DJango
    (add-hook 'pony-tpl-minor-mode-hook #'shackra/pony-remove-beautify-html))

  (use-package virtualenvwrapper
    :after (python)
    :commands (venv-workon venv-deactivate venv-initialize-interactive-shells venv-initialize-eshell)
    :init
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell)
    :config
    (add-hook 'venv-postmkvirtualenv-hook
              (lambda () (shell-command "pip install jedi rope isort epc importmagic yapf pylint"))))

  (use-package pippel)

  (use-package yapfify
    :diminish yapf-mode
    :init (add-hook 'python-mode-hook 'yapf-mode))

  (use-package importmagic
    :diminish 'importmagic-mode
    :init
    (defun shackra/before-save-py-importmagic-fix ()
      (when (eq major-mode 'python-mode) (importmagic-fix-imports)))
    (setq importmagic-be-quiet t)
    (add-hook 'before-save-hook #'shackra/before-save-py-importmagic-fix))

  (use-package isortify
    :ensure t
    :config
    (add-hook 'python-mode-hook 'isort-mode))

  (use-package sphinx-doc
    :after (python)
    :init (add-hook 'python-mode-hook #'sphinx-doc-mode))

  (use-package pydoc-info)

  (use-package company-anaconda
    :if (executable-find "python")
    :after (python company)
    :bind (:map python-mode-map
                ("M-." . anaconda-mode-find-definitions)
                ("M-," . anaconda-mode-find-assignments)
                ("M-r" . anaconda-mode-find-references)
                ("M-*" . anaconda-mode-go-back))
    :diminish anaconda-mode
    :config
    (add-hook 'python-mode-hook (lambda () (add-to-list (make-local-variable 'company-backends) '(company-anaconda :with company-yasnippet company-capf))))
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
    (add-hook 'python-mode-hook 'anaconda-mode))

  (use-package python
    :if (executable-find "python")
    :bind (:map python-mode-map
                ("C-c ," . shackra/python-indent-shift-left)
                ("C-c ." . shackra/python-indent-shift-right))
    :interpreter ("python" . python-mode)
    :init
    (defun shackra/python-indent-shift-left ()
      (interactive)
      (if (fboundp 'hydra-py/body)
          (hydra-py/python-indent-shift-left)
        (python-indent-shift-left)))
    (defun shackra/python-indent-shift-right ()
      (interactive)
      (if (fboundp 'hydra-py/body)
          (hydra-py/python-indent-shift-right)
        (python-indent-shift-right)))
    (defun shackra/python-mode ()
      "Cosas que deseo activar/desactivar cuando voy a programar en Python"
      (shackra/electric-indent-mode-off)
      (aggressive-indent-mode -1))

    (add-hook 'python-mode-hook #'shackra/python-mode)
    :config
    ;; re-mapea todas los atajos que hagan referencia a `python-indent-shift-*' con `shackra/python-indent-shift-*'
    (global-set-key [remap python-indent-shift-left] 'shackra/python-indent-shift-left)
    (global-set-key [remap python-indent-shift-right] 'shackra/python-indent-shift-right))
#+END_SRC
*** LaTeX
Paquete extensivo para escribir y formatear documentos TeX
#+BEGIN_SRC emacs-lisp
  (use-package latex
    :ensure auctex
    :init
    (setf TeX-auto-save t
          TeX-parse-self t
          TeX-save-query nil
          TeX-newline-function 'newline-and-indent
          LaTeX-item-indent 0)
    (setq-default TeX-master nil)
    (setq-default TeX-engine 'xetex)
    (setq-default TeX-PDF-mode t)
    (add-hook 'LaTeX-mode-hook 'yas-minor-mode-on))
  (use-package reftex
    :init
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)   ; with AUCTeX LaTeX mode
    (add-hook 'latex-mode-hook 'turn-on-reftex))   ; with Emacs latex mode
#+END_SRC
*** =toml=
/El lenguaje minimalista y obvio de Tom/
#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :defer 10)
#+END_SRC
*** =yaml=
/YAML: YAML Ain't Markup Language/
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :defer 10
    :mode "\\.yml$")
#+END_SRC
*** =rust=
Modo mayor para editar código fuente en Rust. Rust es es un lenguaje de programación de sistemas que corre realmente rapido, previene fallos de segmentación (segfaults), y garantiza seguridad en programas multi-hilo.
#+BEGIN_SRC emacs-lisp
  (use-package rustfmt
    :disabled ;; no existe en Melpa (20/05/2017)
    :after (rust-mode)
    :config
    (add-hook 'rust-mode-hook #'rustfmt-enable-on-save))
  (use-package cargo
    :after (rust-mode)
    :if (executable-find "cargo"))
  (use-package racer
    :after (rust-mode)
    :init
    (setf racer-rust-src-path (getenv "RUST_SRC_PATH"))
    (setf racer-cmd (expand-file-name "~/.cargo/bin/racer"))
    :config
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode))
  (use-package company-racer
    :after (company racer)
    :config
    (add-hook 'rust-mode-hook '(lambda ()
                                 (add-to-list (make-local-variable 'company-backends) '(company-racer :with company-yasnippet)))))
  (use-package rust-mode
    :if (executable-find "rustc"))
  (use-package flycheck-rust
    :after (flycheck rust-mode)
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC
*** emacs-traad
Una aproximación cliente servidor para usar la librería de refactorización [[https://github.com/python-rope/rope][rope]].
#+BEGIN_SRC emacs-lisp
  (use-package traad-projectile
    :after (traad projectile)
    :preface
    (provide 'traad-projectile)
    :ensure nil
    :no-require t
    :init
    (defun shackra/traad-open ()
      "Inicia un servidor traad usando la ubicación del proyecto actual"
      (interactive)
      (if (projectile-project-p)
          (traad-open (projectile-project-root))
        (message "No estas en ningún proyecto!"))))

  (use-package python-environment
    :init
    (setq python-environment-directory "~/.virtualenvs"))

  (use-package traad
    :after (python-environment)
    :config
    ;; Si aun no se ha creado el entorno virtual para traad, lo mandamos a crear
    ;; de manera automática
    (if (not (file-exists-p (expand-file-name (concat python-environment-directory "/traad"))))
        (traad-install-server)))
  (use-package hydra-traad
    :after (hydra traad python)
    :preface (provide 'hydra-traad)
    :ensure nil
    :no-require t
    :init
    (defhydra hydra-traad-history (:columns 2 :color blue)
      "Historial de cambios de rope"
      ("u" traad-undo "deshacer")
      ("r" traad-redo "re-hacer")
      ("h" traad-display-history "mostrar historial de cambios")
      ("b" hydra-traad/body "volver")
      ("q" nil "salir"))
    (defhydra hydra-traad-rename (:columns 2 :color blue)
      "Renombrar con rope"
      ("f" traad-rename-current-file "archivo/modulo actual")
      ("r" traad-rename "objeto en locación actual")
      ("b" hydra-traad/body "volver")
      ("q" nil "salir"))
    (defhydra hydra-traad-signature (:columns 2 :color blue)
      "Cambiar firma con rope"
      ("n" traad-normalize-arguments "normalizar argumentos")
      ("r" traad-remove-argument "remover argumentos")
      ("b" hydra-traad/body "volver")
      ("q" nil "salir"))
    (defhydra hydra-traad-extraction (:columns 2 :color blue)
      "Extracción con rope"
      ("m" traad-extract-method "método")
      ("v" traad-extract-variable "variable")
      ("b" hydra-traad/body "volver")
      ("q" nil "salir"))
    (defhydra hydra-traad-imports (:columns 3 :color blue)
      "Importaciones con rope"
      ("o" traad-organize-imports "organizar")
      ("s" traad-expand-star-imports "expandir *")
      ("f" traad-froms-to-imports "convertir 'from' a normales")
      ("r" traad-relatives-to-absolutes "convertir relativos a absolutos")
      ("l" traad-handle-long-imports "manejar importaciones largas")
      ("S" traad-imports-super-smackdown "Smackdown!")
      ("b" hydra-traad/body "volver")
      ("q" nil "salir"))
    (defhydra hydra-traad (:columns 2 :columns 2)
      "Refactorización en Python con rope"
      ("h" hydra-traad-history/body "Historial" :exit t)
      ("r" hydra-traad-rename/body "Renombrar" :exit t)
      ("s" hydra-traad-signature/body "Firma" :exit t)
      ("e" hydra-traad-extraction/body "Extracción" :exit t)
      ("i" hydra-traad-imports/body "Importaciones" :exit t)))
#+END_SRC
*** web-mode
Un modo mayor para editar paginas web
#+BEGIN_SRC emacs-lisp
  (use-package web-beautify
    :after (web-mode)
    :config
    (add-hook 'json-mode-hook
              (lambda ()
                (add-hook 'before-save-hook 'web-beautify-js-buffer t t)))
    (add-hook 'html-mode-hook
              (lambda ()
                (add-hook 'before-save-hook 'web-beautify-html-buffer t t)))
    (add-hook 'css-mode-hook
              (lambda ()
                (add-hook 'before-save-hook 'web-beautify-css-buffer t t))))
  (use-package emmet-mode
    :config
    (add-hook 'sgml-mode-hook 'emmet-mode)
    (add-hook 'web-mode-hook 'emmet-mode))
  (use-package company-web
    :after (web-mode)
    :config
    (add-hook 'web-mode-hook (lambda ()
                               (add-to-list (make-local-variable 'company-backends) '(company-web-html :with company-yasnippet)))))
  (use-package ac-html-bootstrap
    :after (company-web)
    :init
    (add-hook 'web-mode-hook 'company-web-bootstrap+)
    (add-hook 'web-mode-hook 'company-web-fa+))
  (use-package web-mode
    :preface
    (defun shackra/webdev-refresh-page-on-save ()
      "Actualiza una pagina web en el navegador al guardar un buffer"
      (interactive)
      (let* ((currentfiledir (file-name-directory (buffer-file-name)))
             (isrootfile (string-suffix-p httpd-root currentfiledir)))
        (when (and (derived-mode-p 'sgml-mode 'css-mode 'web-mode 'js2-mode) isrootfile (shackra/port-open-p moz-repl-host moz-repl-port))
          (moz-controller-page-refresh))))
    :config
    (add-hook 'after-save-hook #'shackra/webdev-refresh-page-on-save)
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))
#+END_SRC
*** PHP
modo mayor para editar código PHP
#+BEGIN_SRC emacs-lisp
  (use-package php-refactor-mode
    :after (php-mode)
    :config
    (add-hook 'php-mode-hook 'php-refactor-mode))
  (use-package php-mode)
#+END_SRC
*** golang
Modo mayor para editar archivos Golang.

Teclas
- @@html:<kbd>M-.</kbd>@@ :: Salta a definición / Go Guru: salto a definición
- @@html:<kbd>C-c C-a</kbd>@@ :: Agrega importación
- @@html:<kbd>C-c C-r</kbd>@@ :: Quita importaciones sin usar
- @@html:<kbd>C-c C-i</kbd>@@ :: Ir a sección donde están las importaciones
- @@html:<kbd>C-c C-c</kbd>@@ :: Compilar proyecto
- @@html:<kbd>C-M-m</kbd>@@ :: Inicia Go Doctor
- @@html:<kbd>C-M-g</kbd>@@ :: Inicia Go Guru

Es necesario instalar [[https://github.com/alecthomas/gometalinter][=gometalinter=]] para localizar varios tipos de errores en el código fuente
#+BEGIN_EXAMPLE
go get -u gopkg.in/alecthomas/gometalinter.v1
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (use-package f) ;; requerido para `shackra/go-update-compile-definition'
  (use-package go-mode
    :after (f)
    :if (executable-find "go")
    :bind (:map go-mode-map
                ("M-." . godef-jump)
                ("C-c C-a" . go-import-add)
                ("C-c C-r" . go-remove-unused-imports)
                ("C-c C-i" . go-goto-imports)
                ("C-c C-c" . compile))
    :init
    (setf gofmt-show-errors nil) ;; para mostrar los errores es que existe Flycheck
    (setf gofmt-command "goimports")
    (defun shackra/go-update-compile-definition ()
      "Actualiza la definición del comando COMPILE para go-mode"
      (interactive)
      (when (eq major-mode 'go-mode)
        (if (string-suffix-p "_test.go" (buffer-name))
            (set (make-local-variable 'compile-command) "go test -bench=. -v")
          (set (make-local-variable 'compile-command) (format "go build && ./%s" (f-base (f-dirname (f-full (buffer-name)))))))))
    :config
    (add-hook 'go-mode-hook (lambda () (add-to-list (make-local-variable 'grep-find-ignored-directories) "vendor")))
    (add-hook 'before-save-hook 'gofmt-before-save)
    (add-hook 'go-mode-hook 'shackra/go-update-compile-definition)
    (add-hook 'after-save-hook 'shackra/go-update-compile-definition))
  (use-package company-go
    :after (go-mode hydra)
    :if (executable-find "gocode")
    :config
    (add-hook 'go-mode-hook (lambda () (add-to-list (make-local-variable 'company-backends) '(company-go :with company-yasnippet)))))
  (use-package go-eldoc
    :after (go-mode hydra)
    :config
    (add-hook 'go-mode-hook 'go-eldoc-setup))
  (use-package go-snippets
    :after (go-mode hydra))
  (use-package godoctor
    :after (go-mode hydra)
    :if (executable-find "godoctor")
    :bind (:map go-mode-map ("C-M-m" . hydra-godoctor/body))
    :config
    (defhydra hydra-godoctor (:color blue :columns 2)
      "Motor de refactorización para Go"
      ("a" godoctor-rename "Renombra identificador, punto actual")
      ("s" godoctor-extract "Refactorizacion en una función, marca actual")
      ("d" godoctor-toggle "Cambia declaración de variable")
      ("f" godoctor-godoc "Crea esqueleto de documentación")))
  (use-package go-guru
    :after (go-mode hydra)
    :if (executable-find "guru")
    :demand t
    :init
    (defun shackra/go-mode-set-scope ()
      (when (eq major-mode 'go-mode)
        (set (make-local-variable 'go-guru-scope)
             (concat (projectile-project-root) "..."))))
    :bind (:map go-mode-map
                ("M-." . go-guru-definition)
                ("C-M-g" . hydra-go-guru/body))
    :config
    (defhydra hydra-go-guru (:color blue :columns 2)
      "Contesta preguntas sobre código fuente escrito en Go"
      ("a" go-guru-callees "Receptores de llamada, función bajo punto actual")
      ("s" go-guru-callers "Llamadores, función bajo punto actual")
      ("d" go-guru-callstack "Muestra grafo de llamadas desde una raíz, función bajo punto actual")
      ("f" go-guru-describe "Describe la sintaxis seleccionada, su tipo y métodos")
      ("g" go-guru-freevars "Enumera las variables libres, marca actual")
      ("h" go-guru-referrers "Enumera referencias al objeto, identificador marcado")
      ("j" go-guru-peers "Enumera un set de remitentes/destinatarios para las operaciones enviar/recibir de este canal")
      ("k" go-guru-pointsto "Muestra lo que apunta, expresión marcada")
      ("l" go-guru-implements "Describe la relación de implementación para tipos en un paquete conteniendo el cursor")
      ("ñ" go-guru-whicherrs "Muestra globales, constantes y tipos, expresión marcada (de tipo 'error')"))
    (add-hook 'go-mode-hook #'go-guru-hl-identifier-mode)
    (add-hook 'projectile-mode-hook #'shackra/go-mode-set-scope))
  (use-package flycheck-gometalinter
    :if (or (executable-find "gometalinter.v1") (executable-find "gometalinter"))
    :after (go-mode flycheck-mode)
    :init
    (if (executable-find "gometalinter.v1")
        (setf flycheck-gometalinter-executable "gometalinter.v1")
      (setf flycheck-gometalinter-executable "gometalinter"))
    (setf flycheck-gometalinter-vendor t)
    (setf flycheck-gometalinter-test t)
    (setf flycheck-gometalinter-fast t)
    (setf flycheck-gometalinter-enable-linters '("unused"))
    (setf flycheck-gometalinter-disable-linters '("gotype"))
    (setq flycheck-gometalinter-deadline "5s")
    :config
    (progn
      (flycheck-gometalinter-setup)))
#+END_SRC
*** javascript
**** JSON
- @@html:<kbd>C-c C-f</kbd>@@: format the region/buffer with [[https://github.com/gongo/json-reformat][=json-reformat=]]
- @@html:<kbd>C-c C-p</kbd>@@: display a path to the object at point with [[https://github.com/Sterlingg/json-snatcher][=json-snatcher=]]
- @@html:<kbd>C-c P</kbd>@@: copy a path to the object at point to the kill ring with =json-snatcher=
- @@html:<kbd>C-c C-t</kbd>@@: Toggle between =true= and =false= at point
- @@html:<kbd>C-c C-k</kbd>@@: Replace the sexp at point with =null=
- @@html:<kbd>C-c C-i</kbd>@@: Increment the number at point
- @@html:<kbd>C-c C-d</kbd>@@: Decrement the number at point
#+BEGIN_SRC emacs-lisp
  (use-package json-mode)
#+END_SRC
**** Dependencias externas
Instalar estos componentes en el sistema operativo
#+BEGIN_SRC sh :dir /sudo:: :results silent
  npm install -g babel-cli babel-preset-react eslint@3.x babel-eslint@7 eslint-plugin-react --save-dev
#+END_SRC
***** configuracion eslint
#+BEGIN_SRC json :tangle ~/.eslintrc
  {
    "parser": "babel-eslint",
    "plugins": [ "react" ],
    "env": {
      "browser": true,
      "es6": true,
      "node": true
    },
    "ecmaFeatures": {
      "arrowFunctions": true,
      "blockBindings": true,
      "classes": true,
      "defaultParams": true,
      "destructuring": true,
      "forOf": true,
      "generators": true,
      "modules": true,
      "spread": true,
      "templateStrings": true,
      "jsx": true
    },
    "rules": {
      "consistent-return": [0],
      "key-spacing": [0],
      "quotes": [0],
      "new-cap": [0],
      "no-multi-spaces": [0],
      "no-shadow": [0],
      "no-unused-vars": [1],
      "no-use-before-define": [2, "nofunc"],
      "react/jsx-no-undef": 1,
      "react/jsx-uses-react": 1,
      "react/jsx-uses-vars": 1
    }
  }
#+END_SRC
**** Paquetes para editar JavaScript
#+BEGIN_SRC emacs-lisp
  (use-package tern
    :if (executable-find "tern")
    :bind (:map tern-mode-keymap
                ("M-." . nil)
                ("M-," . nil)))

  (use-package company-tern
    :after (company tern)
    :if (executable-find "tern")
    :init
    (setf company-tern-property-marker " <p>")
    (setf company-tern-meta-as-single-line t)
    :config
    (dolist (hook '(js2-mode-hook
                    inferior-js-mode-hook))
      (add-hook hook (lambda ()
                       (add-to-list (make-local-variable 'company-backends) '(company-tern :with company-yasnippet))))))
  (use-package js2-refactor
    :after (js2-mode)
    :bind (:js2-mode-map
           ("C-k" . js2r-kill)
           :js-mode-map
           ("M-.". nil))
    :init
    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    :config
    (js2r-add-keybindings-with-prefix "C-c C-r"))

  (use-package xref-js2
    :after (js2-mode)
    :init
    (add-hook 'js2-mode-hook (lambda () (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t))))

  (use-package js2-mode
    :mode "\\.js\\'"
    :init
    (add-hook 'js2-mode-hook #'js2-imenu-extras-mode))
  (use-package indium ;; https://indium.readthedocs.io/en/latest/setup.html
    :config
    (add-hook 'js-mode-hook #'indium-interaction-mode))
#+END_SRC
*** =html-mode=
#+BEGIN_SRC emacs-lisp
  (use-package sgml-mode
    :ensure nil
    :init
    (setf sgml-basic-offset 4))
#+END_SRC
*** Android
Desarrollo de aplicaciones para Android desde GNU Emacs
#+BEGIN_SRC emacs-lisp
  (use-package android-mode
    :init (custom-set-variables '(android-mode-sdk-dir "~/opt/android")))
#+END_SRC
*** SLIME
SLIME is the Superior Lisp Interaction Mode for Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :init
    ;; Estoy leyendo Land of Lisp, así que necesito usar CLISP
    (setf inferior-lisp-program "/usr/bin/clisp")
    (setf slime-contribs '(slime-fancy)))
#+END_SRC
*** Stylus
#+BEGIN_SRC emacs-lisp
  (use-package stylus-mode
    :after (rainbow-mode)
    :init
    (add-hook 'stylus-mode-hook 'rainbow-mode))
#+END_SRC
*** SCSS
#+BEGIN_SRC emacs-lisp
  (use-package scss-mode
    :init (setf scss-compile-at-save nil))
#+END_SRC
*** AngularJS
#+BEGIN_SRC emacs-lisp
  (use-package ng2-mode
    :after (tide))

  (use-package tide
    :init
    (defun setup-tide-mode ()
      (interactive)
      (tide-setup)
      (tide-hl-identifier-mode +1))
    (setf tide-format-options '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t :placeOpenBraceOnNewLineForFunctions nil))
    (setf tide-tsserver-process-environment '("TSS_LOG=-level verbose -file /tmp/tss.log"))
    (add-hook 'before-save-hook 'tide-format-before-save)
    (add-hook 'typescript-mode-hook #'setup-tide-mode)
    (add-hook 'js2-mode-hook #'setup-tide-mode)
    (add-hook 'web-mode-hook (lambda ()
                               (when (string-equal "jsx" (file-name-extension buffer-file-name))
                                 (setup-tide-mode)))))
#+END_SRC
*** Gherkin
#+BEGIN_SRC emacs-lisp
  (use-package feature-mode
    :mode ("\\.feature$" . feature-mode))
#+END_SRC
*** kotlin
#+BEGIN_SRC emacs-lisp
  (use-package kotlin-mode
    :if (executable-find "kotlin"))

  (use-package flycheck-kotlin
    :after (kotlin-mode))

  (use-package gradle-mode
    :after (kotlin-mode))
#+END_SRC
*** Gimp
Now you can run the GIMP with `M-x run-gimp'.
Alternatively, connect to GIMP server with `M-x gimp-cl-connect'.

Type `M-x gimp-help' for help.
#+BEGIN_SRC emacs-lisp
  (use-package gimp-mode
    :ensure nil
    :load-path "site-packages/gimp-mode"
    :config
    (load (expand-file-name "site-packages/gimp-mode/gimp-init.el" user-emacs-directory)))
#+END_SRC
*** Java
#+BEGIN_SRC emacs-lisp
  (use-package meghanada
    :config
    (add-hook 'java-mode-hook
              (lambda ()
                ;; meghanada-mode on
                (meghanada-mode t)
                (setq c-basic-offset 2)
                ;; use code format
                (add-hook 'before-save-hook 'meghanada-code-beautify-before-save))))
#+END_SRC
** Edición de texto y generalidades relacionadas
*** =flyspell-mode=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:56]
- Refiled on [2015-11-12 jue 16:51]
:END:
Revisión ortográfica al vuelo. Asociado a @@html:<kbd>C-.</kbd>@@. @@html:<kbd><f8></kbd>@@ cambia el idioma de Español a Inglés y viceversa.
#+BEGIN_SRC emacs-lisp
  (use-package flyspell-correct-ivy
    :after (flyspell ivy-mode)
    :bind (:map flyspell-mode-map ("C-." . flyspell-correct-previous-word-generic))
    :init
    (setf flyspell-correct-auto-delay 2.0))
  (use-package flyspell
    :if (or (executable-find "ispell") (executable-find "hunspell"))
    :diminish flyspell-mode
    :ensure nil
    :init
    ;; sacado de http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html
    ;; if (aspell installed) { use aspell}
    ;; else if (hunspell installed) { use hunspell }
    ;; whatever spell checker I use, I always use English dictionary
    ;; I prefer use aspell because:
    ;; 1. aspell is older
    ;; 2. looks Kevin Atkinson still get some road map for aspell:
    ;; @see http://lists.gnu.org/archive/html/aspell-announce/2011-09/msg00000.html
    (defun flyspell-detect-ispell-args (&optional run-together)
      "if RUN-TOGETHER is true, spell check the CamelCase words."
      (let (args)
        (cond
         ((string-match  "aspell$" ispell-program-name)
          ;; Force the Spanish dictionary for aspell
          ;; Support Camel Case spelling check (tested with aspell 0.6)
          (setq args (list "--sug-mode=ultra" "--lang=es_ES"))
          (if run-together
              (setq args (append args '("--run-together" "--run-together-limit=5" "--run-together-min=2")))))
         ((string-match "hunspell$" ispell-program-name)
          ;; Force the Spanish dictionary for hunspell
          (setq args "-d es_ES")))
        args))

    (cond
     ((executable-find "aspell")
      ;; you may also need `ispell-extra-args'
      (setq ispell-program-name "aspell"))
     ((executable-find "hunspell")
      (setq ispell-program-name "hunspell")

      ;; Please note that `ispell-local-dictionary` itself will be passed to hunspell cli with "-d"
      ;; it's also used as the key to lookup ispell-local-dictionary-alist
      ;; if we use different dictionary
      (setq ispell-local-dictionary "es_ES")
      (setq ispell-local-dictionary-alist
            '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
              ("es_ES" "[[:alpha:]]" "[^[:alpha:]]" "[ñ]" nil ("-d" "es_ES") nil utf-8))))
     (t (setq ispell-program-name nil)))

    ;; ispell-cmd-args is useless, it's the list of *extra* arguments we will append to the ispell process when "ispell-word" is called.
    ;; ispell-extra-args is the command arguments which will *always* be used when start ispell process
    ;; Please note when you use hunspell, ispell-extra-args will NOT be used.
    ;; Hack ispell-local-dictionary-alist instead.
    (setq-default ispell-extra-args (flyspell-detect-ispell-args t))
    ;; (setq ispell-cmd-args (flyspell-detect-ispell-args))
    (defadvice ispell-word (around my-ispell-word activate)
      (let ((old-ispell-extra-args ispell-extra-args))
        (ispell-kill-ispell t)
        (setq ispell-extra-args (flyspell-detect-ispell-args))
        ad-do-it
        (setq ispell-extra-args old-ispell-extra-args)
        (ispell-kill-ispell t)))

    (defadvice flyspell-auto-correct-word (around my-flyspell-auto-correct-word activate)
      (let ((old-ispell-extra-args ispell-extra-args))
        (ispell-kill-ispell t)
        ;; use emacs original arguments
        (setq ispell-extra-args (flyspell-detect-ispell-args))
        ad-do-it
        ;; restore our own ispell arguments
        (setq ispell-extra-args old-ispell-extra-args)
        (ispell-kill-ispell t)))

    (defadvice flyspell-correct-word-generic (around my-flyspell-correct-word-generic activate)
      (let ((old-ispell-extra-args ispell-extra-args))
        (ispell-kill-ispell t)
        ;; use emacs original arguments
        (setq ispell-extra-args (flyspell-detect-ispell-args))
        ad-do-it
        ;; restore our own ispell arguments
        (setq ispell-extra-args old-ispell-extra-args)
        (ispell-kill-ispell t)))

    (defun text-mode-hook-setup ()
      ;; Turn off RUN-TOGETHER option when spell check text-mode
      (setq-local ispell-extra-args (flyspell-detect-ispell-args)))
    :config
    (add-hook 'text-mode #'text-mode-hook-setup))

  (use-package shackra/ispell-dict-switch
    :bind (("<f8>" . shackra/ispell-cycle-dict))
    :no-require t
    :ensure nil
    :preface (provide 'shackra/ispell-dict-switch)
    :config
    (setf shackra/ispell-dict-list (list "es" "en"))
    :init
    (defvar shackra/ispell-dict-list (list) "Lista de diccionarios para cambiar")

    (defun shackra--ispell-current-dict ()
      "Obtiene el diccionario actual o retorna el establecido por defecto"
      (if ispell-current-dictionary
          (cl-position ispell-current-dictionary shackra/ispell-dict-list :test 'string=)
        (if (stringp (getenv "LANG"))
            (cl-position (nth 0 (split-string (getenv "LANG") "_")) shackra/ispell-dict-list :test 'string=)
          0))) ;; retorna español mientras tanto

    (defun shackra/ispell-cycle-dict ()
      "Cambia de un diccionario a otro"
      (interactive)
      (let ((dict-list-size (- (length shackra/ispell-dict-list) 1))
            (dict-current-index (shackra--ispell-current-dict)))
        (if (> (+ dict-current-index 1) dict-list-size)
            (setf dict-current-index 0)
          (setf dict-current-index (+ dict-current-index 1)))
        ;; luego de realizar la matemática, cambiamos el diccionario
        (ispell-change-dictionary (nth dict-current-index shackra/ispell-dict-list)))
      ;; Nuevo diccionario, nada de palabras subrayadas
      (flyspell-delete-all-overlays)
      ;; Mandamos a revisar la ortografía del párrafo en que estamos
      (flyspell-region (line-beginning-position) (line-end-position))))
#+END_SRC
*** =flycheck-mode=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:56]
- Refiled on [2015-11-12 jue 16:51]
:END:
Revisión de errores en el código fuente, al vuelo.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-package :after (flycheck))
  (use-package flycheck
    :diminish flycheck-mode
    :init
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc javascript-jshint))
    (setf flycheck-indication-mode 'left-fringe)
    (setf flycheck-display-errors-delay 5.0)
    :config
    (add-hook 'prog-mode-hook #'flycheck-mode))
#+END_SRC
*** =multiple-cursors=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:56]
- Refiled on [2015-11-12 jue 16:51]
:END:
Multiples cursores en Emacs. Asociado a @@html:<kbd>C-c n</kbd>@@
#+BEGIN_SRC emacs-lisp
  (use-package hydra-mc
    :no-require t
    :ensure nil
    :preface (provide 'hydra-mc)
    :after (multiple-cursors hydra)
    :init
    (defhydra hydra-mc-next (:columns 4 :color amaranth)
      "Multiple-cursors: Siguiente"
      ("n"    mc/mark-next-like-this "Como este")
      ("N"    mc/unmark-next-like-this "Desmarcar")
      ("M-n"  mc/skip-to-next-like-this "Saltar")
      ("C-n"  mc/mark-next-lines "Linea")
      ("SPC" nil "Salir" :color blue))
    (defhydra hydra-mc-previous (:columns 4 :color amaranth)
      "Multiple-cursors: Anterior"
      ("p"   mc/mark-previous-like-this "Como este")
      ("P"   mc/unmark-previous-like-this "Desmarcar")
      ("M-p" mc/skip-to-previous-like-this "Saltar")
      ("C-p" mc/mark-previous-lines "Linea")
      ("SPC" nil "Salir" :color blue))
    (bind-keys :prefix-map shackra/mc-map
	       :prefix "C-c n"
	       ("n"   . hydra-mc-next/mc/mark-next-like-this)
	       ("N"   . hydra-mc-next/mc/unmark-next-like-this)
	       ("M-n" . hydra-mc-next/mc/skip-to-next-like-this)
	       ("C-n" . hydra-mc-next/mc/mark-next-lines)
	       ("p"   . hydra-mc-previous/mc/mark-previous-like-this)
	       ("P"   . hydra-mc-previous/mc/unmark-previous-like-this)
	       ("M-p" . hydra-mc-previous/mc/skip-to-previous-like-this)
	       ("C-p" . hydra-mc-previous/mc/mark-previous-lines)))

  (use-package multiple-cursors
    :config
    (bind-keys :prefix-map shackra/mc-map
	       :prefix "C-c n"
	       ("n"   . mc/mark-next-like-this)
	       ("N"   . mc/unmark-next-like-this)
	       ("M-n" . mc/skip-to-next-like-this)
	       ("C-n" . mc/mark-next-lines)
	       ("p"   . mc/mark-previous-like-this)
	       ("P"   . mc/unmark-previous-like-this)
	       ("M-p" . mc/skip-to-previous-like-this)
	       ("C-p" . mc/mark-previous-lines)
	       ("a"   . mc/mark-all-dwim)
	       ("A"   . mc/mark-all-like-this-dwim)
	       ("M-a" . mc/mark-all-like-this-in-defun)
	       ("M-A" . mc/mark-all-words-like-this-in-defun)
	       ("0"   . mc/insert-numbers)
	       ("h"   . mc/mark-sgml-tag-pair)
	       ("s"   . mc/sort-regions)
	       ("m"   . set-rectangular-region-anchor)
	       ("r"   . mc/reverse-regions)
	       ("M-l" . mc/edit-lines)
	       ("l"   . mc/edit-beginnings-of-lines)
	       ("C-l" . mc/edit-ends-of-lines)))
#+END_SRC
*** =pcre2el=
Convierte entre sintaxis de expresiones regulares PCRE, Emacs y RX.

#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :diminish pcre-mode
    :config (pcre-mode t))
#+END_SRC
*** =visual-fill-column=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:57]
- Refiled on [2015-11-12 jue 16:49]
:END:
/fill-column for visual-line-mode/
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :defer t)
#+END_SRC
*** =subword-mode=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:57]
- Refiled on [2015-11-12 jue 16:50]
:END:
Navegación y edición de /SubPalabras/. Siendo "HolaMundoAdios" una nomenclatura, =subword-mode= permite mover el cursor entre cada subpalabra, deteniéndolo en "Adios", "Mundo" y "Hola" si se mueve el cursor de derecha a izquierda presionando la tecla CTRL. Este modo menor es muy útil, especialmente para aquellos desarrolladores en Java que usan variables con JorobasDeCamello.
#+BEGIN_SRC emacs-lisp
  (use-package subword
    :ensure nil
    :diminish subword-mode)
#+END_SRC
*** =hungry-delete=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:58]
- Refiled on [2015-11-12 jue 16:53]
:END:
Borra espacios en blanco consecutivos con sólo presionar =backspace= una vez :)
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :diminish hungry-delete-mode
    :config
    (global-hungry-delete-mode))
#+END_SRC
*** =aggressive-indent-mode=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:58]
- Refiled on [2015-11-12 jue 16:53]
:END:
Porque =electric-indent-mode= no es lo suficientemente bueno.
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :diminish aggressive-indent-mode
    :config
    (add-to-list
     'aggressive-indent-dont-indent-if
     '(and (derived-mode-p 'c++-mode)
           (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                               (thing-at-point 'line)))))
    (global-aggressive-indent-mode 1)
    (add-to-list 'aggressive-indent-excluded-modes 'html-mode))
#+END_SRC
*** =text-mode=
:LOGBOOK:
- Refiled on [2015-11-12 jue 17:00]
:END:
Cualquier modo mayor que /herede/ de =text-mode= sera afectado por esta configuración.
#+BEGIN_SRC emacs-lisp
  (defun shackra/text-mode ()
    (when (or (executable-find "ispell") (executable-find "hunspell"))(flyspell-mode))
    (set (make-local-variable 'fill-column) 100)
    (turn-off-auto-fill)
    (turn-on-visual-line-mode))
  (remove-hook 'text-mode-hook #'turn-on-auto-fill)
  (add-hook 'text-mode-hook #'shackra/text-mode)
#+END_SRC
**** Mover el cursos de manera inteligente al inicio de la linea
He tenido el problema, desde que no uso =auto-indent-mode=, que al presionar M-a el cursor va a la columna 0 en lugar de posicionarse en el primer carácter no-blanco de la linea, que es un comportamiento deseado cuando se esta programando. En [[http://stackoverflow.com/a/145359/2020214][Stackoverflow hay una respuesta]] para el problema :)
#+BEGIN_SRC emacs-lisp
  (use-package sbol
    :no-require t
    :ensure nil
    :preface (provide 'sbol)
    :bind (([home] . smart-beginning-of-line)
	   ("C-a" . smart-beginning-of-line))
    :init
    (defun smart-beginning-of-line ()
      "Move point to first non-whitespace character or beginning-of-line.

  Move point to the first non-whitespace character on this line.
  If point was already at that position, move point to beginning of line."
    (interactive)
    (let ((oldpos (point)))
      (back-to-indentation)
      (and (= oldpos (point))
	   (beginning-of-line)))))
#+END_SRC
*** transcription-mode
Modo mayor para editar transcripciones
#+BEGIN_SRC emacs-lisp
  (use-package transcription-mode
    :ensure nil
    :load-path "site-packages/transcription-mode")
#+END_SRC
*** paredit
Un modo menor para la edición de paréntesis. Para aprender qué hace este modo menor y sus posibilidades, ver [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][The Animated Guide to Paredit]].
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :diminish paredit-mode
    :config
    (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
    (add-hook 'lisp-mode-hook 'enable-paredit-mode)
    (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode))
#+END_SRC
*** Move-text
Mover texto a voluntad
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :config (move-text-default-bindings))
#+END_SRC
** Otros
*** golden-ratio-scroll-screen
Subraya la linea anterior y la siguiente luego de hacer saltar de linea el cursor del mouse
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio-scroll-screen
    :config
    (global-set-key [remap scroll-down-command] 'golden-ratio-scroll-screen-down)
    (global-set-key [remap scroll-up-command] 'golden-ratio-scroll-screen-up))
#+END_SRC
*** =htmlize=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:47]
:END:
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC
*** mustache
#+BEGIN_SRC emacs-lisp
  (use-package mustache-mode)
#+END_SRC
*** =fixmee=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:49]
:END:
Subraya cualquier termino "TODO" en cualquier modo mayor de programación.
#+BEGIN_SRC emacs-lisp
  (use-package fixmee
    :diminish fixmee-mode
    :defer 5
    :config
    (add-hook 'prog-mode #'fixmee-mode))
#+END_SRC
*** all-the-icons
Paquete de utilidades para formatear varios fuentes de iconos dentro de Emacs
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC
*** =telephone-line=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:50]
:END:
"/Soy como =powerline=, pero mejor/"
#+BEGIN_SRC emacs-lisp
  (use-package telephone-line
    :preface (defun shackra/vc-state ()
               (if vc-mode
                   (vc-state (buffer-file-name (current-buffer)))
                 nil))
    :init
    ;; define una nueva cara
    (defface shackra-orange '((t (:foreground "black" :background "orange"))) "")
    ;; Informa a telephine-line sobre la existencia de la nueva cara, llamada `orange'
    ;; Cambia el estilo de los separadores
    (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
          telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
          telephone-line-primary-right-separator 'telephone-line-cubed-right
          telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
    (setf telephone-line-height 40)
    (custom-set-faces
     '(mode-line ((t (:box nil))))
     '(mode-line-inactive ((t (:box nil))))
     '(mode-line-highlight ((t (:box nil)))))
    :config
    (add-to-list 'telephone-line-faces '(accent-orange . (shackra-orange . telephone-line-accent-inactive)))
    (telephone-line-defsegment* shackra-buffer-vc-modified-segment ()
      (list (cond ((buffer-modified-p)
                   (propertize (format " %s" (all-the-icons-faicon "pencil")) 'face `(:height 1.3 :family ,(all-the-icons-faicon-family))
                               'display '(raise -0.1) 'help-echo "Buffer modificado."))
                  ((eq (shackra/vc-state) 'edited)
                   (propertize (format " %s?" (all-the-icons-faicon "cloud-upload")) 'face `(:height 1.3 :family ,(all-the-icons-faicon-family))
                               'display '(raise -0.1) 'help-echo "Cambios sin registrar.")))
            (cond ((eq (shackra/vc-state) 'missing)
                   (propertize (format " %s " (all-the-icons-faicon "trash")) 'face `(:height 1.3 :family ,(all-the-icons-faicon-family))
                               'display '(raise -0.1) 'help-echo "Archivo sólo existe en VCS, no en el disco duro."))
                  ((eq (shackra/vc-state) 'ignored)
                   (propertize (format " %s " (all-the-icons-faicon "ban")) 'face `(:height 1.3 :family ,(all-the-icons-faicon-family))
                               'display '(raise -0.1) 'help-echo "Archivo ignorado"))
                  ((eq (shackra/vc-state) 'added)
                   (propertize (format " %s " (all-the-icons-faicon "plus")) 'face `(:height 1.3 :family ,(all-the-icons-faicon-family))
                               'display '(raise -0.1) 'help-echo "Archivo será registrado en VCS en el siguiente commit."))
                  ((eq (shackra/vc-state) 'unregistered)
                   (propertize (format " %s " (all-the-icons-faicon "question")) 'face `(:height 1.3 :family ,(all-the-icons-faicon-family))
                               'display '(raise -0.1) 'help-echo "Archivo sin registrar al VCS.")))))

    (telephone-line-defsegment shackra-virtualenv-name () (if venv-current-name
                                                              (format "venv: %s" venv-current-name)
                                                            nil))

    (telephone-line-defsegment shackra-line-buffer-segment ()
      (telephone-line-raw mode-line-buffer-identification t))

    (telephone-line-defsegment* shackra-vc-info ()
      (when vc-mode
        (cond ((string-match "Git[:-]" vc-mode)
               (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
                 (concat
                  (propertize (format " %s" (all-the-icons-faicon "git-square" :v-adjust -0.1)) 'face `(:foreground "orange" :height 1.3 :family ,(all-the-icons-octicon-family)))
                  (propertize (format "%s" branch) 'face `(:foreground "orange")))))
              (t (format "%s" vc-mode)))))
    (telephone-line-defsegment* shackra-flycheck-status ()
      (let* ((text (pcase flycheck-last-status-change
                     (`finished (if flycheck-current-errors
                                    (let ((count (let-alist (flycheck-count-errors flycheck-current-errors)
                                                   (+ (or .warning 0) (or .error 0)))))
                                      (propertize (format " ✖ %s problema%s" count (if (> count 1) "s" "")) 'face `(:foreground "orange")))
                                  (propertize " ✔ Sin problemas" 'face `(:foreground "dark grey"))))
                     (`running     (propertize " ⟲ En ejecución" 'face `(:foreground "deep sky blue")))
                     (`no-checker  (propertize " ⚠ No existe revisor" 'face `(:foreground "dim grey")))
                     (`not-checked (propertize " ✖ Sin revisar" 'face `(:foreground "dim grey")))
                     (`errored     (propertize " ⚠ Error" 'face `(:foreground "tomato")))
                     (`interrupted (propertize " ⛔ Interrumpido" 'face `(:foreground "tomato")))
                     (`suspicious  ""))))
        (propertize text
                    'help-echo "Muestra errores detectados por Flycheck"
                    'local-map (make-mode-line-mouse-map
                                'mouse-1 (lambda () (interactive) (flycheck-list-errors))))))

    (setf telephone-line-lhs
          '((accent . (shackra-line-buffer-segment shackra-buffer-vc-modified-segment))
            (nil .  (shackra-vc-info shackra-flycheck-status))))

    (setf telephone-line-rhs '((nil . (telephone-line-misc-info-segment telephone-line-major-mode-segment))
                               (accent-orange . (shackra-virtualenv-name))
                               (accent . (telephone-line-position-segment))))
    (telephone-line-mode 1))
#+END_SRC
*** =visual-line-mode=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:50]
:END:
Envuelve las filas de texto si son muy anchas visualmente en nuevas filas.
#+BEGIN_SRC emacs-lisp
  (setf visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
#+END_SRC
*** =notify=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:52]
:END:
Permite a emacs enviar notificaciones por DBus o diferentes medios. En este caso usare libnotify (el método definido no es multiplataforma).
#+BEGIN_SRC emacs-lisp
  (setf notify-method 'notify-via-libnotify)
#+END_SRC
*** =vimish-fold=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:53]
:END:
Pleguar o desplegar bloques de texto. Asociado a @@html:<kbd>C-c v</kbd>@@.
#+BEGIN_SRC emacs-lisp
  (use-package vimish-fold
    :defer 10
    :config
    (bind-keys :prefix-map shackra/vimish-fold-map
               :prefix "C-c v"
               ("v" . vimish-fold-toggle)
               ("V" . vimish-fold-toggle-all)
               ("f" . vimish-fold)
               ("u" . vimish-fold-unfold)
               ("u" . vimish-fold-unfold-all)
               ("d" . vimish-fold-delete)
               ("D" . vimish-fold-delete-all)
               ("n" . vimish-fold-next-fold)
               ("p" . vimish-fold-previous-fold))
    (add-hook 'prog-mode #'vimish-fold-mode))
#+END_SRC
*** =appt=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:53]
:END:
Appointments me alerta de mis citas o pendientes que tengo por hacer.
#+BEGIN_SRC emacs-lisp
  (use-package alert
    :init
    (if (eq system-type 'windows-nt)
        (setf alert-default-style 'message)
      (setf alert-default-style 'libnotify))
    :config
    (defun shackra/appt-muestra-notificacion (min-to-app new-time msg)
      "Envia notificaciones usando libnotify. Esto no funcionara si DBus no esta instalado y corriendo"
      ;; `min-to-app' puede ser una lista, o no.
      (if (atom min-to-app)
          (alert
           (if (<= (string-to-number min-to-app) 1)
               (format "<b>Cita en %s minuto</b>" min-to-app)
             (format "<b>Cita en %s minutos</b>" min-to-app))
           :title msg
           :mode 'Emacs-Org
           :severity 'high
           :persistent t)
        ;; no entiendo este trozo de código, pero asumo que itera una lista de
        ;; cosas por hacer.
        (dolist (i (number-sequence 0 (1- (length min-to-app))))
          (alert
           (if (<= (string-to-number (nth i min-to-app)) 1)
               (format "<b>Cita en %s minuto</b>" (nth i min-to-app))
             (format "<b>Cita en %s minutos</b>" (nth i min-to-app)))
           :title (nth i msg)
           :mode 'Emacs-Org
           :severity 'high
           :persistent t)))))
  ;; configuración adaptada de http://emacs.stackexchange.com/a/5821/690 Gracias
  ;; a http://redd.it/35kbf6
  (use-package appt
    :after (alert)
    :if (not (eq system-type 'darwin))
    :ensure nil
    :init
    (setf appt-message-warning-time 10
          appt-display-interval (1+ appt-message-warning-time)
          appt-display-mode-line nil)
    ;; Muestra las citas como notificaciones en el manejador de ventanas
    (setf appt-disp-window-function 'shackra/appt-muestra-notificacion)
    ;;(setf appt-delete-window-function nil)
    :config
    (defun shackra/appt-update-when-file-updated ()
      "Actualiza appt cuando ciertos archivos son actualizados"
      ;; si `org-directory' es prefijo en el nombre del archivo del buffer
      ;; actual, ejecuta la funcion `shackra/org-agenda-to-appt'
      (if (string-prefix-p org-directory (buffer-file-name))
          (shackra/org-agenda-to-appt)))

    (defun shackra/org-agenda-to-appt ()
      (interactive)
      (setf appt-time-msg-list nil)
      (org-agenda-to-appt))

    (shackra/org-agenda-to-appt)
    (run-at-time "12:05am" (* 24 3600) 'shackra/org-agenda-to-appt)
    (appt-activate t)
    ;; automáticamente actualiza las citas cuando el archivo cosasporhacer.org es
    ;; salvado (ahí es donde yo guardo mi lista de cosas por hacer, y mi agenda)
    (add-hook 'after-save-hook #'shackra/appt-update-when-file-updated))
#+END_SRC
*** =uniquify=
:LOGBOOK:
- Refiled on [2015-11-12 jue 16:54]
:END:
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :ensure nil
    :init
    (setf uniquify-buffer-name-style 'forward))
#+END_SRC
*** =systemd=
Modo mayor para editar archivos de servicio systemd.
#+BEGIN_SRC emacs-lisp
  (use-package systemd)
#+END_SRC
*** =pretty-mode=
#+BEGIN_SRC emacs-lisp
  (use-package pretty-mode
    :config
    (add-hook 'prog-mode-hook 'turn-on-pretty-mode))
#+END_SRC
*** interfaz para AUR
#+BEGIN_SRC emacs-lisp
  (use-package aurel
    :init
    (setf aurel-download-directory "~/proyectos/aur/aurel")
    (setf aurel-aur-user-package-info-check t))
#+END_SRC
*** =golden-ratio=
Redimensiona las ventanas para hacer más cómoda la edición en cualquiera de ellas
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :disabled
    :diminish golden-ratio-mode
    :init
    (setf golden-ratio-auto-scale nil)
    :config
    (golden-ratio-mode 1))
#+END_SRC
*** RSS feed
Lector de RSS feed dentro de Emacs
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :bind (:map elfeed-show-mode-map (("." . elfeed-open-url)))
    :init
    (setf url-queue-timeout 30)
    (defun elfeed-open-url ()
      "Open an URL with eww"
      (interactive)
      (let* ((url-to-visit))
        (save-excursion
          (goto-char (point-min))
          (search-forward "Link: " nil t)
          (setf url-to-visit (thing-at-point 'url t)))
        (eww url-to-visit)))
    (defun elfeed-search-format-date (date)
      (format-time-string "%d-%m-%Y %H:%M" (seconds-to-time date)))
    ;; fuentes RSS feed
    (setf elfeed-feeds '(("https://www.aciprensa.com/rss/noticias.xml" Iglesia noticias)
                         ("http://feeds.feedburner.com/santodeldia" Iglesia santoral)
                         ("http://www.asianews.it/es.xml" Iglesia asía)
                         ("http://localhost:9077/feed/crhoy/atom" noticias nacionales)
                         ("http://localhost:9077/feed/rt-espanol/atom" noticias internacionales)
                         ("https://godotengine.org/rss.xml" godot gamedev)))
    :config
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :before "2 weeks ago"
                                  :remove 'unread))
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :feed-url "\\.crhoy\\.com"
                                  :entry-title "Video"
                                  :remove 'unread)))
#+END_SRC
*** =ws-butler=
Eliminación de espacios de manera no obstrusiva
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :diminish ws-butler-mode
    :config
    (add-hook 'prog-mode-hook 'ws-butler-mode)
    (add-hook 'text-mode-hook 'ws-butler-mode))
#+END_SRC
*** Mingus
Cliente para MPD
#+BEGIN_SRC emacs-lisp
  (use-package mingus
    :if (executable-find "mpd"))
#+END_SRC
*** camcorder
Permite hacer screen-casts de pequeños frames de Emacs y convertir eso a un GIF
#+BEGIN_SRC emacs-lisp
  (use-package camcorder)
#+END_SRC
*** Shackle
Como =display-buffer-alist= pero más sencillo
#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :init
    (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :size 0.3)
                          ((circe-server-mode circe-channel-mode circe-query-mode) :ignore t)
                          (compilation-mode :select t :align 'right :size 0.3)))
    :config
    (add-hook 'after-init-hook 'shackle-mode))
#+END_SRC
*** pdf-tools
Mejor visor de PDFs para Emacs
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-view-mode))
#+END_SRC
*** Emojify 😏
Muestra imágenes de emojis en lugar de los caracteres utf-8
#+BEGIN_SRC emacs-lisp
  (use-package emojify
    ;; Este paquete sólo funciona si la versión de Emacs es mayor o igual a 24.3
    ;; y Emacs fue compilado con soporte para PNG
    :if (and (version<= "24.3" emacs-version) (image-type-available-p 'png))
    :init
    (add-hook 'after-init-hook #'global-emojify-mode))
  (use-package company-emoji
    :after (emojify)
    :config (add-hook 'text-mode-hook
                      (lambda ()
                        (add-to-list
                         (make-local-variable 'company-backends) '(company-emoji :with company-yasnippet)))))
#+END_SRC
*** free-keys
Muestra cuales combinaciones de teclas están libres para asignar. Asociado @@html:<kbd>C-h C-k</kbd>@@.
#+BEGIN_SRC emacs-lisp
  (use-package free-keys
    :bind (:map help-map
                ("C-k" . free-keys)))
#+END_SRC
*** Pocket
#+BEGIN_SRC emacs-lisp
  (use-package el-pocket
    :preface (require 'thingatpt)
    :bind (:map mu4e-view-mode-map ("l" . el-pocket-add-url-at-point))
    :init (defun el-pocket-add-url-at-point ()
            "Add URL at point to Pocket"
            (interactive)
            (let* ((url-shr (get-text-property (point) 'shr-url))
                   (url-at-point (thing-at-point 'url))
                   (url (or url-shr url-at-point)))
              (el-pocket-add-url url)))
    :config (el-pocket-load-auth))
#+END_SRC
*** highlight-indent-guides
Modo menor que subraya los niveles de identación en el buffer usando font-lock. Los anchos de identación son descubiertos de manera dinámica.
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :after (python-mode)
    :init
    (setf highlight-indent-guides-method 'fill)
    (add-hook 'python-mode 'highlight-indent-guides-mode))
#+END_SRC
**** Limitaciones
Este modo menor no funciona bien con otros modos menores que hacen uso de la propiedad =display= de los textos en el buffer o que modifican como se muestran los espacios en blanco como hace whitespace-mode. Más info: [[https://github.com/DarthFennec/highlight-indent-guides#limitations][Limitations]].
*** Manejador de procesos para el sistema
#+BEGIN_SRC emacs-lisp
  (use-package proced
    :ensure nil
    :if (or (string-equal system-type "gnu/linux") (string-equal system-type "gnu/kfreebsd")))
#+END_SRC
*** schrute-mode
Recuerda al usuario que hay una manera más eficiente de hacer algo
#+BEGIN_SRC emacs-lisp
  (use-package schrute
    :disabled
    :ensure nil
    :load-path "site-packages/dwight"
    :init
    (defun shackra/super-next-line ()
      (interactive)
      (ignore-errors (forward-line 3)))
    (defun shackra/super-previous-line ()
      (interactive)
      (ignore-errors (forward-line -3)))
    (defun shackra/super-left-char ()
      (interactive)
      (ignore-errors (left-char 3)))
    (defun shackra/super-right-char ()
      (interactive)
      (ignore-errors (right-char 3)))
    (defun shackra/super-forward-word ()
      (interactive)
      (ignore-errors (forward-word 3)))
    (defun shackra/super-backward-word ()
      (interactive)
      (ignore-errors (backward-word 3)))
    (setf schrute-command-repetitions 1)
    (setf schrute-lighter " 🐻 ")
    (setf schrute-shortcuts-commands '((shackra/super-next-line     . (next-line))
                                       (shackra/super-previous-line . (previous-line))
                                       (shackra/super-left-char     . (left-char))
                                       (shackra/super-right-char    . (right-char))
                                       (shackra/super-forward-word  . (forward-word))
                                       (shackra/super-backward-word . (backward-word))))
    (add-hook 'after-init-hook #'schrute-mode))
#+END_SRC
*** Yasnippet en todos los backends de Company                   :especial:
Company-mode siempre escogerá *un* backend a la vez, la única forma de hacer que muestre candidatos de auto-completado y candidatos yasnippet es agrupando los backends
#+BEGIN_SRC emacs-lisp
  ;; http://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names
  ;; Add yasnippet support for all company backends
  ;; https://github.com/syl20bnr/spacemacs/pull/179

  (defun company-mode/backend-with-yas (backend)
    (if (or (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))

  (add-hook 'after-init-hook (lambda () (setf company-backends (mapcar #'company-mode/backend-with-yas company-backends))) t)
#+END_SRC
*** =webpaste=
Pega regiones o buffers completos en servicios como pastebin
#+BEGIN_SRC emacs-lisp
  (use-package webpaste
    :bind (("C-c C-p C-b" . webpaste-paste-buffer)
           ("C-c C-p C-r" . webpaste-paste-region)))
#+END_SRC
*** Chronos
Multiples temporizadores simultaneos
#+BEGIN_SRC emacs-lisp
  (use-package chronos
    :init
    (setf chronos-expiry-functions '(chronos-desktop-notifications-notify)))
#+END_SRC
*** docker 🐋
Utilidades para integrar Emacs y docker
#+BEGIN_SRC emacs-lisp
  (use-package docker
    :config
    (docker-global-mode))

  (use-package docker-compose-mode)

  (use-package dockerfile-mode
    :mode "Dockerfile\\'")
#+END_SRC
*** Depuración
#+BEGIN_SRC emacs-lisp
  (use-package realgud)
#+END_SRC
